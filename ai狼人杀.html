<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Áãº‰∫∫ÊùÄÂâßÂú∫</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: { zinc: { 850: '#1f1f22', 950: '#09090b' } },
                    animation: { 'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
                }
            }
        };
    </script>

    <!-- React & Libraries -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap');
        body { font-family: 'Inter', 'Noto Sans SC', sans-serif; }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(156, 163, 175, 0.3); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(156, 163, 175, 0.5); }

        .typing-dot { animation: typing 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        .fade-enter { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }

        .toast-container { position: fixed; top: 20px; right: 20px; z-index: 100; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { pointer-events: auto; padding: 10px 16px; border-radius: 8px; color: white; font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: fadeIn 0.3s ease; max-width: 300px; }
        .toast.error { background-color: #ef4444; }
        .toast.success { background-color: #22c55e; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- Defaults ---
        const DEFAULT_MODEL_CONFIGS = [
            { id: 'config-1', name: 'DeepSeek API', provider: 'openai', baseUrl: 'https://api.deepseek.com', apiKey: '', model: 'deepseek-chat' },
            { id: 'config-2', name: 'Google Gemini', provider: 'google', baseUrl: 'https://generativelanguage.googleapis.com', apiKey: '', model: 'gemini-1.5-flash' }
        ];

        const DEFAULT_SYSTEM_PROMPTS = [
            { id: 'prompt-1', name: 'ÁêÜ‰∏≠ÂÆ¢Âä©Êâã', content: '‰Ω†ÊòØ‰∏Ä‰∏™ÁêÜÊô∫„ÄÅÂÆ¢ËßÇ„ÄÅÊúâÈÄªËæëÁöÑÂä©Êâã„ÄÇ‰Ω†ÁöÑÂõûÁ≠îÈÄöÂ∏∏ÊØîËæÉÊ≠£ÂºèÔºåÂñúÊ¨¢ÂàóÂá∫‰∏Ä‰∫å‰∏âÁÇπ„ÄÇ‰Ω†‰∏ç‰ºöËΩªÊòìÂèëÁÅ´„ÄÇ' },
            { id: 'prompt-2', name: 'Êö¥Ë∫ÅËÄÅÂì•', content: '‰Ω†ÊòØ‰∏Ä‰∏™ËÑæÊ∞îÊö¥Ë∫Å„ÄÅËØ¥ËØùÁõ¥Êé•„ÄÅÂñúÊ¨¢ÂêêÊßΩÂíåÊä¨Êù†ÁöÑÁΩëÂèã„ÄÇ‰Ω†Áúã‰∏çÊÉØÂà´‰∫∫Ë£ÖÊ®°‰ΩúÊ†∑ÔºåÂñúÊ¨¢Áî®ËÆΩÂà∫ÁöÑËØ≠Ê∞î„ÄÇ‰Ω†ÁªèÂ∏∏‰ΩøÁî®‚ÄúÁ¨ëÊ≠ª‚Äù„ÄÅ‚ÄúÂæó‰∫ÜÂêß‚ÄùÁ≠âÂè£ËØ≠„ÄÇ' },
            { id: 'prompt-3', name: 'ÂêÉÁìúÁæ§‰ºó', content: '‰Ω†ÊòØ‰∏Ä‰∏™ÂÖ∏ÂûãÁöÑ‚ÄúÂêÉÁìúÁæ§‰ºó‚ÄùÔºåÊÄßÊ†ºÈöèÂíåÔºåÊúâÁÇπËø∑Á≥ä„ÄÇ‰Ω†ÂñúÊ¨¢ÂèëÈ¢úÊñáÂ≠óÔºåÁªèÂ∏∏ËØ¥‰∫õÊúâÁöÑÊ≤°ÁöÑÔºåÊàñËÄÖÂú®Ê∞îÊ∞õÁ¥ßÂº†Êó∂ÊâìÂúÜÂú∫„ÄÇ‰Ω†‰∏çÊìÖÈïøËß£ÂÜ≥Â§çÊùÇÈóÆÈ¢òÔºå‰ΩÜÊìÖÈïøÊ¥ªË∑ÉÊ∞îÊ∞õ„ÄÇ' }
        ];

        const DEFAULT_AGENTS = [
            { id: 'agent-1', name: 'ÁêÜ‰∏≠ÂÆ¢', avatarColor: 'bg-blue-500', configId: 'config-1', promptId: 'prompt-1', enabled: true },
            { id: 'agent-2', name: 'Êö¥Ë∫ÅËÄÅÂì•', avatarColor: 'bg-red-500', configId: 'config-1', promptId: 'prompt-2', enabled: true },
            { id: 'agent-3', name: 'Ë∑Ø‰∫∫Áî≤', avatarColor: 'bg-green-500', configId: 'config-1', promptId: 'prompt-3', enabled: true }
        ];

        const DEFAULT_DIRECTOR_RULE = `‰Ω†ÊòØ‰∏Ä‰∏™Áæ§ËÅäÂØºÊºî„ÄÇËØ∑Ê†πÊçÆ‰∏ä‰∏ãÊñáÂÜ≥ÂÆö‰∏ã‰∏Ä‰ΩçÂèëË®ÄËÄÖ„ÄÇ
    ÂèØÈÄâÊºîÂëò:
    {agent_descriptions}

    ËßÑÂàô:
    1. ËøîÂõûJSON: {"next_speaker_id": "ID", "reason": "ÁêÜÁî±"}
    2. Ëã•Êó†ÈúÄÂèëË®ÄËøîÂõû null ID„ÄÇ
    3. Â∞ΩÈáèËÆ©ÂØπËØùËá™ÁÑ∂ÊúâË∂£„ÄÇ
    4. Â¶ÇÊûúÁî®Êà∑ËØ¢ÈóÆÔºåËØ∑ÊåáÊ¥æÊúÄÂêàÈÄÇÁöÑËßíËâ≤ÂõûÁ≠î„ÄÇ`;

        const DEFAULT_WEREWOLF_ROLE_PROMPTS = {
            wolf: '‰Ω†ÊòØÁãº‰∫∫„ÄÇ‰Ω†ÁöÑÁõÆÊ†áÊòØÈöêÁûíË∫´‰ªΩÂπ∂Â∏¶È¢ÜÁãºÈòüËé∑ËÉú„ÄÇÂèëË®ÄÊó∂Ë¶ÅÊúâÈÄªËæë‰ΩÜÈÅøÂÖçÊö¥Èú≤„ÄÇ',
            villager: '‰Ω†ÊòØÊùëÊ∞ë„ÄÇ‰Ω†ÁöÑÁõÆÊ†áÊòØÈÄöËøáËÆ®ËÆ∫‰∏éÊäïÁ•®ÊâæÂá∫Áãº‰∫∫„ÄÇÂèëË®ÄË¶ÅÁªìÂêà‰∫ãÂÆû‰∏éÈÄªËæë„ÄÇ',
            seer: '‰Ω†ÊòØÈ¢ÑË®ÄÂÆ∂„ÄÇ‰Ω†ÂèØ‰ª•Âú®Á¨¨‰∏ÄÂ§úÊü•È™å‰∏ÄÂêçÁé©ÂÆ∂ÁöÑË∫´‰ªΩ„ÄÇÁôΩÂ§©ÂèëË®ÄÂèØÂºïÂØº‰ΩÜÈÅøÂÖçÊö¥Èú≤ËøáÊó©„ÄÇ',
            witch: '‰Ω†ÊòØÂ•≥Â∑´„ÄÇ‰Ω†Êúâ‰∏ÄÁì∂Ëß£ËçØÂíå‰∏ÄÁì∂ÊØíËçØ„ÄÇ‰Ω†ÈúÄË¶ÅÂà§Êñ≠ÊòØÂê¶Êïë‰∫∫ÊàñÊØí‰∫∫„ÄÇ',
            hunter: '‰Ω†ÊòØÁåé‰∫∫„ÄÇ‰Ω†Ê≠ª‰∫°Êó∂ÂèØ‰ª•Â∏¶Ëµ∞‰∏ÄÂêçÁé©ÂÆ∂„ÄÇËØ∑Âú®Ë¢´Ê∑òÊ±∞Êó∂ÊûúÊñ≠ÈÄâÊã©ÁõÆÊ†á„ÄÇ',
            guard: '‰Ω†ÊòØÂÆàÂç´„ÄÇÊØèÊôöÂèØ‰ª•ÂÆàÊä§‰∏ÄÂêçÁé©ÂÆ∂Ôºå‰ΩÜ‰∏çËÉΩËøûÁª≠ÂÆàÊä§Âêå‰∏Ä‰∫∫„ÄÇ',
            idiot: '‰Ω†ÊòØÁôΩÁó¥„ÄÇË¢´ÊäïÁ•®Âá∫Â±ÄÂèØÁøªÁâåÂÖçÊ≠ªÔºå‰ΩÜÂ§±ÂéªÊäïÁ•®ÊùÉ„ÄÇ'
        };

        // --- Icons ---
        const Icon = ({ path, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{path}</svg>
        );
        const Icons = {
            Plus: (p) => <Icon path={<><path d="M5 12h14"/><path d="M12 5v14"/></>} {...p} />,
            Trash: (p) => <Icon path={<><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>} {...p} />,
            X: (p) => <Icon path={<><path d="M18 6 6 18"/><path d="m6 6 12 12"/></>} {...p} />,
            Settings: (p) => <Icon path={<><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></>} {...p} />,
            Send: (p) => <Icon path={<><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></>} {...p} />,
            User: (p) => <Icon path={<><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></>} {...p} />,
            Moon: (p) => <Icon path={<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>} {...p} />,
            Sun: (p) => <Icon path={<><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></>} {...p} />,
            Play: (p) => <Icon path={<polygon points="5 3 19 12 5 21 5 3"/>} {...p} />,
            Pause: (p) => <Icon path={<><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></>} {...p} />,
            Users: (p) => <Icon path={<><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></>} {...p} />,
            Brain: (p) => <Icon path={<path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/>} {...p} />,
            Edit: (p) => <Icon path={<><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></>} {...p} />,
            CheckCircle: (p) => <Icon path={<><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></>} {...p} />,
            Activity: (p) => <Icon path={<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>} {...p} />,
            Loader: (p) => <Icon path={<path d="M21 12a9 9 0 1 1-6.219-8.56"/>} className={`animate-spin ${p.className}`} {...p} />,
            Save: (p) => <Icon path={<><path d="M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/><path d="M17 21v-8H7v8"/><path d="M7 3v5h8"/></>} {...p} />,
            Database: (p) => <Icon path={<><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></>} {...p} />,
            Zap: (p) => <Icon path={<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>} {...p} />,
            FileText: (p) => <Icon path={<><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><polyline points="10 9 9 9 8 9"/></>} {...p} />,
            Clapperboard: (p) => <Icon path={<><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/></>} {...p} />,
            Download: (p) => <Icon path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></>} {...p} />,
            Copy: (p) => <Icon path={<><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></>} {...p} />,
            AtSign: (p) => <Icon path={<><circle cx="12" cy="12" r="4"/><path d="M16 8v5a3 3 0 0 1-3 3H7a5 5 0 1 1 4.5-8"/></>} {...p} />,
            Wolf: (p) => <Icon path={<><path d="M12 2c-2 0-3.5 1-4 2.5-.5-.5-1.5-1-3-1 0 2 1 3 2 3.5-1 1-1.5 2.5-1.5 4.5 0 4 3 7.5 6.5 7.5s6.5-3.5 6.5-7.5c0-2-.5-3.5-1.5-4.5 1-.5 2-1.5 2-3.5-1.5 0-2.5.5-3 1-.5-1.5-2-2.5-4-2.5z"/><circle cx="9" cy="10" r="1"/><circle cx="15" cy="10" r="1"/></>} {...p} />,
            Shield: (p) => <Icon path={<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>} {...p} />,
            Eye: (p) => <Icon path={<><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>} {...p} />,
            Skull: (p) => <Icon path={<><circle cx="12" cy="10" r="8"/><path d="M12 18v4"/><path d="M8 22h8"/><circle cx="9" cy="9" r="1.5"/><circle cx="15" cy="9" r="1.5"/><path d="M9 14h6"/></>} {...p} />,
            Target: (p) => <Icon path={<><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></>} {...p} />,
        };

        const cn = (...classes) => classes.filter(Boolean).join(' ');

        const safeParse = (raw, fallback) => {
            if (!raw) return fallback;
            try {
                const parsed = JSON.parse(raw);
                return parsed ?? fallback;
            } catch (e) {
                return fallback;
            }
        };

        // --- UI Components ---
        const Toast = ({ toasts, removeToast }) => (
            <div className="toast-container">
                {toasts.map(t => (
                    <div key={t.id} className={`toast ${t.type === 'error' ? 'error' : 'success'}`} onClick={() => removeToast(t.id)}>
                        {t.msg}
                    </div>
                ))}
            </div>
        );

        // --- Logic ---
        const callLLM = async (messages, config, onUpdate, onComplete, onError) => {
            if (!config || !config.apiKey) {
                onError("ÈÖçÁΩÆÊó†ÊïàÔºöÁº∫Â∞ë API Key");
                return;
            }

            const baseUrl = (config.baseUrl || 'https://api.deepseek.com').replace(/\/+$/, '');
            let url, body, headers;

            try {
                if (config.provider === 'google') {
                    const model = config.model || 'gemini-1.5-flash';
                    url = `${baseUrl}/v1beta/models/${model}:streamGenerateContent?key=${config.apiKey}&alt=sse`;
                    headers = { 'Content-Type': 'application/json' };
                    body = JSON.stringify({
                        contents: messages.map(m => ({
                            role: m.role === 'user' ? 'user' : 'model',
                            parts: [{ text: m.content }]
                        }))
                    });
                } else {
                    url = `${baseUrl}/chat/completions`;
                    headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apiKey}` };
                    body = JSON.stringify({
                        model: config.model || 'deepseek-chat',
                        messages: messages,
                        stream: true
                    });
                }

                let response = await fetch(url, { method: 'POST', headers, body });
                if (response.status === 404 && config.provider !== 'google' && !url.includes('/v1/')) {
                    const v1Url = `${baseUrl}/v1/chat/completions`;
                    const resV1 = await fetch(v1Url, { method: 'POST', headers, body });
                    if (resV1.status !== 404) response = resV1;
                }

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errText.substring(0,100)}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (config.provider === 'google') {
                            if (trimmed.startsWith('data: ')) {
                                try {
                                    const json = JSON.parse(trimmed.substring(6));
                                    const content = json.candidates?.[0]?.content?.parts?.[0]?.text;
                                    if (content) onUpdate(content);
                                } catch (e) {}
                            }
                        } else {
                            if (trimmed.startsWith('data: ') && trimmed !== 'data: [DONE]') {
                                try {
                                    const json = JSON.parse(trimmed.substring(6));
                                    const content = json.choices?.[0]?.delta?.content;
                                    if (content) onUpdate(content);
                                } catch (e) {}
                            }
                        }
                    }
                }
                onComplete();
            } catch (e) {
                onError(e.message);
            }
        };

        const callGoogle = async (apiKey, baseUrl, model, text) => {
            const url = `${baseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text }] }] })
            });
            if (!res.ok) throw new Error(`Google API Error: ${res.status}`);
            const data = await res.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text;
        };

        const callOpenAI = async (apiKey, baseUrl, model, text) => {
            let cleanBase = (baseUrl || '').replace(/\/+$/, '');
            let url = `${cleanBase}/chat/completions`;

            const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };
            const body = JSON.stringify({
                model: model,
                messages: [{ role: "user", content: text }],
                stream: false,
                max_tokens: 50
            });

            let res = await fetch(url, { method: 'POST', headers, body });
            if (res.status === 404 && !url.includes('/v1/')) {
                url = `${cleanBase}/v1/chat/completions`;
                res = await fetch(url, { method: 'POST', headers, body });
            }

            if (!res.ok) throw new Error(`API Error: ${res.status}`);
            const data = await res.json();
            return data.choices?.[0]?.message?.content;
        };

        // --- Config Modal (Werewolf Only) ---
        const GlobalConfigModal = ({ open, onClose, configs, setConfigs, prompts, setPrompts, directorConfigId, setDirectorConfigId, directorRule, setDirectorRule, directorMode, setDirectorMode, contextWindowSize, setContextWindowSize, werewolfRolePrompts, setWerewolfRolePrompts, darkMode, addToast }) => {
            const [activeTab, setActiveTab] = useState('models'); // 'models' | 'prompts' | 'director'

            const [editingConfigId, setEditingConfigId] = useState(null);
            const [localConfigs, setLocalConfigs] = useState(configs);
            const [availableModels, setAvailableModels] = useState([]);
            const [isChecking, setIsChecking] = useState(false);
            const [isTesting, setIsTesting] = useState(false);

            const [editingPromptId, setEditingPromptId] = useState(null);
            const [localPrompts, setLocalPrompts] = useState(prompts);

            const [localDirectorRule, setLocalDirectorRule] = useState(directorRule);
            const [localDirectorMode, setLocalDirectorMode] = useState(directorMode);
            const [localContextWindowSize, setLocalContextWindowSize] = useState(contextWindowSize);
            const [localWerewolfRolePrompts, setLocalWerewolfRolePrompts] = useState(werewolfRolePrompts);

            const [isRenaming, setIsRenaming] = useState(false);
            const [renameValue, setRenameValue] = useState("");

            useEffect(() => {
                if (open) {
                    setLocalConfigs(configs);
                    setLocalPrompts(prompts);
                    setLocalDirectorRule(directorRule);
                    setLocalDirectorMode(directorMode);
                    setLocalContextWindowSize(contextWindowSize);
                    setLocalWerewolfRolePrompts(werewolfRolePrompts);
                    setEditingConfigId(configs[0]?.id || null);
                    setEditingPromptId(prompts[0]?.id || null);
                    setIsRenaming(false);
                }
            }, [open, configs, prompts, directorRule, directorMode, contextWindowSize, werewolfRolePrompts]);

            if (!open) return null;

            const DIRECTOR_MODE_HELP = {
                ai: {
                    title: 'AI ÂØºÊºîÔºàËá™Âä®Ë∞ÉÂ∫¶Ôºâ',
                    desc: 'Áî±ÂØºÊºîÊ®°ÂûãÊ†πÊçÆËßÑÂàô‰∏é‰∏ä‰∏ãÊñáÂÜ≥ÂÆö‰∏ã‰∏Ä‰ΩçÂèëË®ÄËÄÖ„ÄÇ',
                    tips: [
                        'Á≥ªÁªü‰ºöËá™Âä®Â∞Ü {agent_descriptions} ÊõøÊç¢‰∏∫ÂΩìÂâçÂêØÁî®ÁöÑÊºîÂëòÂàóË°®„ÄÇ',
                        '‰Ω†ÂèØ‰ª•Ê∑ªÂä†ËßÑÂàôÔºå‰æãÂ¶ÇÔºö‚ÄúÂ¶ÇÊûúÁî®Êà∑Âú®ÊèêÈóÆÔºåÂøÖÈ°ªËÆ©‚ÄòÁêÜ‰∏≠ÂÆ¢‚ÄôÂõûÁ≠î‚Äù„ÄÇ',
                        '‰Ω†ÂèØ‰ª•Â¢ûÂä†ÂÜ≤Á™ÅÔºå‰æãÂ¶ÇÔºö‚ÄúÈºìÂä±ÊºîÂëò‰∫íÁõ∏ÂèçÈ©≥ÂØπÊñπÁöÑËßÇÁÇπ‚Äù„ÄÇ'
                    ],
                    usesPrompt: true
                },
                default: {
                    title: 'ÈªòËÆ§Ê®°ÂºèÔºà@ÁÇπÂêçÔºâ',
                    desc: '‰ªÖÂìçÂ∫î @ÁÇπÂêç/@ÊâÄÊúâ‰∫∫ ÊàñÈ°∫Â∫èËá™Âä®ÂèëË®ÄÔºå‰∏ç‰ΩøÁî®ÂØºÊºîËßÑÂàô„ÄÇ',
                    tips: [
                        'ËØ•Ê®°Âºè‰∏ç‰ºöË∞ÉÁî®ÂØºÊºîÊ®°Âûã„ÄÇ',
                        'ÂØºÊºîËßÑÂàô‰∏ç‰ºöÁîüÊïà„ÄÇ'
                    ],
                    usesPrompt: false
                },
                werewolf: {
                    title: 'Áãº‰∫∫ÊùÄÊ®°Âºè',
                    desc: 'ËøõÂÖ•Áãº‰∫∫ÊùÄÊ∏∏ÊàèÊµÅÁ®ã‰∏éËßÑÂàôÊéßÂà∂Ôºå‰∏ç‰ΩøÁî®ÂØºÊºîË∞ÉÂ∫¶ËßÑÂàô„ÄÇ',
                    tips: [
                        'ËÅäÂ§©‰ºöË¢´Ê∏∏ÊàèÈò∂ÊÆµÈ©±Âä®„ÄÇ',
                        'ÂØºÊºîËßÑÂàô‰∏ç‰ºöÁîüÊïà„ÄÇ'
                    ],
                    usesPrompt: false
                }
            };
            const activeDirectorHelp = DIRECTOR_MODE_HELP[localDirectorMode] || DIRECTOR_MODE_HELP.ai;

            const activeConfig = localConfigs.find(c => c.id === editingConfigId) || localConfigs[0];
            const updateConfig = (field, value) => {
                setLocalConfigs(prev => prev.map(c => c.id === editingConfigId ? { ...c, [field]: value } : c));
            };

            const addConfig = () => {
                const newId = `config-${Date.now()}`;
                const newConfig = { id: newId, name: 'Êñ∞ÈÖçÁΩÆ', provider: 'openai', baseUrl: 'https://api.deepseek.com', apiKey: '', model: 'deepseek-chat' };
                setLocalConfigs([...localConfigs, newConfig]);
                setEditingConfigId(newId);
                setIsRenaming(false);
            };

            const deleteConfig = () => {
                if (localConfigs.length <= 1) return addToast("Ëá≥Â∞ë‰øùÁïô‰∏Ä‰∏™Ê®°ÂûãÈÖçÁΩÆ", "error");
                if (confirm(`Á°ÆÂÆöÂà†Èô§ ${activeConfig.name}?`)) {
                    const next = localConfigs.filter(c => c.id !== editingConfigId);
                    setLocalConfigs(next);
                    setEditingConfigId(next[0].id);
                    setIsRenaming(false);
                }
            };

            const fetchModels = async () => {
                if (!activeConfig.apiKey) return addToast("ËØ∑ÂÖàÂ°´ÂÜô API Key", "error");
                setIsChecking(true);
                try {
                    const baseUrl = (activeConfig.baseUrl || '').replace(/\/+$/, '');
                    if (activeConfig.provider === 'google') {
                        const res = await fetch(`${baseUrl}/v1beta/models?key=${activeConfig.apiKey}`);
                        if (!res.ok) throw new Error(res.status);
                        const data = await res.json();
                        const ids = data.models?.filter(m => m.supportedGenerationMethods?.includes("generateContent")).map(m => m.name.replace('models/', '')) || [];
                        setAvailableModels(ids);
                        addToast(`Ëé∑ÂèñÂà∞ ${ids.length} ‰∏™Ê®°Âûã`);
                        if (ids.length && !activeConfig.model) updateConfig('model', ids[0]);
                    } else {
                        let res = await fetch(`${baseUrl}/models`, { headers: { 'Authorization': `Bearer ${activeConfig.apiKey}` } });
                        if (res.status === 404 && !baseUrl.includes('/v1')) res = await fetch(`${baseUrl}/v1/models`, { headers: { 'Authorization': `Bearer ${activeConfig.apiKey}` } });
                        if (!res.ok) throw new Error(res.status);
                        const data = await res.json();
                        const ids = (data.data || []).map(m => m.id).sort();
                        setAvailableModels(ids);
                        addToast(`Ëé∑ÂèñÂà∞ ${ids.length} ‰∏™Ê®°Âûã`);
                        if (ids.length && !activeConfig.model) updateConfig('model', ids[0]);
                    }
                } catch (e) {
                    addToast(`Ëé∑ÂèñÂ§±Ë¥•: ${e.message}`, "error");
                } finally {
                    setIsChecking(false);
                }
            };

            const testModel = async () => {
                if (!activeConfig.apiKey || !activeConfig.model) return addToast("ËØ∑ÂÆåÂñÑÈÖçÁΩÆ", "error");
                setIsTesting(true);
                try {
                    const baseUrl = (activeConfig.baseUrl || '').replace(/\/+$/, '');
                    if (activeConfig.provider === 'google') await callGoogle(activeConfig.apiKey, baseUrl, activeConfig.model, "Hi");
                    else await callOpenAI(activeConfig.apiKey, baseUrl, activeConfig.model, "Hi");
                    addToast("ÊµãËØïÈÄöËøáÔºÅÊ®°ÂûãÂèØÁî®");
                } catch (e) {
                    addToast(`ÊµãËØïÂ§±Ë¥•: ${e.message}`, "error");
                } finally {
                    setIsTesting(false);
                }
            };

            const activePrompt = localPrompts.find(p => p.id === editingPromptId) || localPrompts[0];
            const updatePrompt = (field, value) => {
                setLocalPrompts(prev => prev.map(p => p.id === editingPromptId ? { ...p, [field]: value } : p));
            };

            const addPrompt = () => {
                const newId = `prompt-${Date.now()}`;
                setLocalPrompts([...localPrompts, { id: newId, name: 'Êñ∞ÂâßÊú¨', content: '‰Ω†ÊòØ‰∏Ä‰∏™...' }]);
                setEditingPromptId(newId);
                setIsRenaming(false);
            };

            const deletePrompt = () => {
                if (localPrompts.length <= 1) return addToast("Ëá≥Â∞ë‰øùÁïô‰∏Ä‰∏™ÂâßÊú¨", "error");
                if (confirm(`Á°ÆÂÆöÂà†Èô§ ${activePrompt.name}?`)) {
                    const next = localPrompts.filter(p => p.id !== editingPromptId);
                    setLocalPrompts(next);
                    setEditingPromptId(next[0].id);
                    setIsRenaming(false);
                }
            };

            const handleSaveAll = () => {
                setConfigs(localConfigs);
                setPrompts(localPrompts);
                setDirectorRule(localDirectorRule);
                setDirectorMode(localDirectorMode);
                setContextWindowSize(Number(localContextWindowSize) || 5);
                setWerewolfRolePrompts(localWerewolfRolePrompts);
                addToast("ÊâÄÊúâÈÖçÁΩÆÂ∑≤‰øùÂ≠ò");
                onClose();
            };

            const startRename = (currentName) => {
                setRenameValue(currentName);
                setIsRenaming(true);
            };

            const finishRenameModel = () => {
                if(renameValue.trim()) updateConfig('name', renameValue.trim());
                setIsRenaming(false);
            };

            const finishRenamePrompt = () => {
                if(renameValue.trim()) updatePrompt('name', renameValue.trim());
                setIsRenaming(false);
            };

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 fade-enter">
                    <div className={cn("w-full max-w-4xl rounded-xl shadow-2xl flex flex-col h-[85vh]", darkMode ? "bg-zinc-900 border border-zinc-800 text-zinc-100" : "bg-white text-zinc-900")}>
                        <div className="p-4 border-b border-zinc-200 dark:border-zinc-800 flex justify-between items-center shrink-0">
                            <h3 className="text-lg font-bold flex items-center gap-2"><Icons.Database className="w-5 h-5" /> ÂÖ®Â±ÄËµÑÊ∫êÈÖçÁΩÆ‰∏≠ÂøÉ</h3>
                            <button onClick={onClose}><Icons.X className="w-5 h-5" /></button>
                        </div>

                        <div className="flex flex-1 overflow-hidden">
                            <div className="w-48 border-r border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-950/50 p-3 space-y-1 shrink-0">
                                <button onClick={() => { setActiveTab('models'); setIsRenaming(false); }} className={cn("w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors", activeTab === 'models' ? "bg-purple-600 text-white" : "hover:bg-zinc-200 dark:hover:bg-zinc-800 text-zinc-600 dark:text-zinc-400")}>
                                    <Icons.Zap className="w-4 h-4"/> AI Ê®°ÂûãËøûÊé•
                                </button>
                                <button onClick={() => { setActiveTab('prompts'); setIsRenaming(false); }} className={cn("w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors", activeTab === 'prompts' ? "bg-purple-600 text-white" : "hover:bg-zinc-200 dark:hover:bg-zinc-800 text-zinc-600 dark:text-zinc-400")}>
                                    <Icons.FileText className="w-4 h-4"/> ‰∫∫ËÆæÂâßÊú¨Â∫ì
                                </button>
                                <button onClick={() => { setActiveTab('director'); setIsRenaming(false); }} className={cn("w-full flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors", activeTab === 'director' ? "bg-purple-600 text-white" : "hover:bg-zinc-200 dark:hover:bg-zinc-800 text-zinc-600 dark:text-zinc-400")}>
                                    <Icons.Clapperboard className="w-4 h-4"/> ÂØºÊºî (ËßÑÂàô)
                                </button>
                            </div>

                            <div className="flex-1 flex overflow-hidden">
                                {activeTab === 'models' && (
                                    <>
                                        <div className="w-56 border-r border-zinc-200 dark:border-zinc-800 overflow-y-auto p-2">
                                            <div className="flex justify-between items-center px-2 mb-2">
                                                <span className="text-xs font-bold text-zinc-500">Â∑≤Â≠òÈÖçÁΩÆ</span>
                                                <button onClick={addConfig} className="text-purple-500 hover:bg-purple-100 dark:hover:bg-purple-900/20 p-1 rounded"><Icons.Plus className="w-3 h-3"/></button>
                                            </div>
                                            {localConfigs.map(c => (
                                                <div key={c.id} onClick={() => { setEditingConfigId(c.id); setAvailableModels([]); setIsRenaming(false); }} className={cn("px-3 py-2 rounded text-sm cursor-pointer truncate mb-1 border", editingConfigId === c.id ? "border-purple-500 bg-purple-50 dark:bg-purple-900/20 text-purple-600 dark:text-purple-300" : "border-transparent hover:bg-zinc-100 dark:hover:bg-zinc-800")}>
                                                    {c.name}
                                                </div>
                                            ))}
                                        </div>
                                        <div className="flex-1 p-6 overflow-y-auto custom-scrollbar space-y-5">
                                            <div className="flex justify-between items-center group">
                                                <div className="flex-1 flex items-center gap-2">
                                                    {isRenaming ? (
                                                        <div className="flex items-center gap-2 w-full">
                                                            <input 
                                                                value={renameValue} 
                                                                onChange={e => setRenameValue(e.target.value)}
                                                                onBlur={finishRenameModel}
                                                                onKeyDown={e => e.key === 'Enter' && finishRenameModel()}
                                                                autoFocus
                                                                className={cn("text-lg font-bold bg-transparent border-b-2 border-purple-500 outline-none w-full pb-1", darkMode ? "text-white" : "text-zinc-900")} 
                                                            />
                                                            <button onClick={finishRenameModel} className="text-green-500 hover:text-green-600"><Icons.CheckCircle className="w-5 h-5"/></button>
                                                        </div>
                                                    ) : (
                                                        <div className="flex items-center gap-2 cursor-pointer hover:opacity-80" onClick={() => startRename(activeConfig.name)}>
                                                            <h2 className="text-lg font-bold truncate">{activeConfig.name}</h2>
                                                            <Icons.Edit className="w-4 h-4 text-zinc-400 opacity-0 group-hover:opacity-100 transition-opacity"/>
                                                        </div>
                                                    )}
                                                </div>
                                                <button onClick={deleteConfig} className="text-red-500 p-2 hover:bg-red-50 dark:hover:bg-red-900/20 rounded ml-4"><Icons.Trash className="w-4 h-4"/></button>
                                            </div>

                                            <div className="grid grid-cols-2 gap-4">
                                                <div>
                                                    <label className="block text-xs font-medium text-zinc-500 mb-1">ÊúçÂä°ÂïÜ</label>
                                                    <select value={activeConfig.provider} onChange={e => updateConfig('provider', e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}>
                                                        <option value="openai">OpenAI ÂÖºÂÆπ (DeepSeek/GPT)</option>
                                                        <option value="google">Google Gemini</option>
                                                    </select>
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-zinc-500 mb-1">Base URL</label>
                                                    <input value={activeConfig.baseUrl} onChange={e => updateConfig('baseUrl', e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm font-mono", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")} />
                                                </div>
                                            </div>

                                            <div>
                                                <label className="block text-xs font-medium text-zinc-500 mb-1">API Key</label>
                                                <input type="password" value={activeConfig.apiKey} onChange={e => updateConfig('apiKey', e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm font-mono", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")} placeholder="sk-..." />
                                            </div>

                                            <div>
                                                <label className="block text-xs font-medium text-zinc-500 mb-1">Ê®°Âûã ID (Model)</label>
                                                <div className="flex gap-2 items-center">
                                                    <div className="flex-1 relative">
                                                        {availableModels.length > 0 ? (
                                                            <select value={activeConfig.model} onChange={e => updateConfig('model', e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm font-mono appearance-none", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}>
                                                                {availableModels.map(m => <option key={m} value={m}>{m}</option>)}
                                                            </select>
                                                        ) : (
                                                            <input value={activeConfig.model} onChange={e => updateConfig('model', e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm font-mono", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")} placeholder="‰æãÂ¶Ç: deepseek-chat" />
                                                        )}
                                                    </div>

                                                    <button onClick={fetchModels} disabled={isChecking} className={cn("px-3 py-2 rounded text-sm font-medium whitespace-nowrap flex items-center gap-1.5 transition-colors border shadow-sm", isChecking ? "opacity-50" : "", darkMode ? "bg-zinc-800 border-zinc-700 hover:bg-zinc-700 text-zinc-200" : "bg-white border-zinc-200 hover:bg-zinc-50 text-zinc-700")}>
                                                        {isChecking ? <Icons.Loader className="w-4 h-4"/> : <Icons.Activity className="w-4 h-4 text-purple-500"/>}
                                                        Ëé∑ÂèñÂàóË°®
                                                    </button>
                                                    <button onClick={testModel} disabled={isTesting} className={cn("px-3 py-2 rounded text-sm font-medium whitespace-nowrap flex items-center gap-1.5 transition-colors border shadow-sm", isTesting ? "opacity-50" : "", darkMode ? "bg-green-900/20 border-green-900/30 text-green-400 hover:bg-green-900/30" : "bg-green-50 border-green-100 text-green-600 hover:bg-green-100")}>
                                                        {isTesting ? <Icons.Loader className="w-4 h-4"/> : <Icons.CheckCircle className="w-4 h-4"/>}
                                                        ËøûÈÄöÊµãËØï
                                                    </button>
                                                </div>
                                                <p className="text-[10px] text-zinc-500 mt-2 flex items-center gap-1">
                                                    <Icons.Zap className="w-3 h-3"/> ÊèêÁ§∫ÔºöËæìÂÖ• Key ÂêéÂÖàÁÇπÂáª‚ÄúËé∑ÂèñÂàóË°®‚ÄùÔºåËã•Â§±Ë¥•ËØ∑Ê£ÄÊü• Base URL„ÄÇ
                                                </p>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {activeTab === 'prompts' && (
                                    <>
                                        <div className="w-56 border-r border-zinc-200 dark:border-zinc-800 overflow-y-auto p-2">
                                            <div className="flex justify-between items-center px-2 mb-2">
                                                <span className="text-xs font-bold text-zinc-500">ÂâßÊú¨Â∫ì</span>
                                                <button onClick={addPrompt} className="text-purple-500 hover:bg-purple-100 dark:hover:bg-purple-900/20 p-1 rounded"><Icons.Plus className="w-3 h-3"/></button>
                                            </div>
                                            {localPrompts.map(p => (
                                                <div key={p.id} onClick={() => { setEditingPromptId(p.id); setIsRenaming(false); }} className={cn("px-3 py-2 rounded text-sm cursor-pointer truncate mb-1 border", editingPromptId === p.id ? "border-purple-500 bg-purple-50 dark:bg-purple-900/20 text-purple-600 dark:text-purple-300" : "border-transparent hover:bg-zinc-100 dark:hover:bg-zinc-800")}>
                                                    {p.name}
                                                </div>
                                            ))}
                                        </div>
                                        <div className="flex-1 p-6 overflow-y-auto custom-scrollbar space-y-5">
                                            <div className="flex justify-between items-center group">
                                                <div className="flex-1 flex items-center gap-2">
                                                    {isRenaming ? (
                                                        <div className="flex items-center gap-2 w-full">
                                                            <input 
                                                                value={renameValue} 
                                                                onChange={e => setRenameValue(e.target.value)}
                                                                onBlur={finishRenamePrompt}
                                                                onKeyDown={e => e.key === 'Enter' && finishRenamePrompt()}
                                                                autoFocus
                                                                className={cn("text-lg font-bold bg-transparent border-b-2 border-purple-500 outline-none w-full pb-1", darkMode ? "text-white" : "text-zinc-900")} 
                                                            />
                                                            <button onClick={finishRenamePrompt} className="text-green-500 hover:text-green-600"><Icons.CheckCircle className="w-5 h-5"/></button>
                                                        </div>
                                                    ) : (
                                                        <div className="flex items-center gap-2 cursor-pointer hover:opacity-80" onClick={() => startRename(activePrompt.name)}>
                                                            <h2 className="text-lg font-bold truncate">{activePrompt.name}</h2>
                                                            <Icons.Edit className="w-4 h-4 text-zinc-400 opacity-0 group-hover:opacity-100 transition-opacity"/>
                                                        </div>
                                                    )}
                                                </div>
                                                <button onClick={deletePrompt} className="text-red-500 p-2 hover:bg-red-50 dark:hover:bg-red-900/20 rounded ml-4"><Icons.Trash className="w-4 h-4"/></button>
                                            </div>
                                            <div className="flex-1 flex flex-col h-full pb-10">
                                                <label className="block text-xs font-medium text-zinc-500 mb-1">Á≥ªÁªüÊèêÁ§∫ËØç (System Prompt)</label>
                                                <textarea 
                                                    value={activePrompt.content}
                                                    onChange={e => updatePrompt('content', e.target.value)}
                                                    className={cn("flex-1 w-full p-4 rounded border text-sm resize-none leading-relaxed font-mono", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}
                                                    placeholder="‰Ω†ÊòØ‰∏Ä‰∏™..."
                                                />
                                            </div>
                                        </div>
                                    </>
                                )}

                                {activeTab === 'director' && (
                                    <div className="flex-1 p-6 overflow-y-auto custom-scrollbar flex flex-col h-full">
                                        <h2 className="text-lg font-bold mb-4 flex items-center gap-2"><Icons.Clapperboard className="w-5 h-5"/> ÂØºÊºî (Ë∞ÉÂ∫¶ËßÑÂàô)</h2>
                                        <div className="grid grid-cols-2 gap-4 mb-4">
                                            <div>
                                                <label className="block text-xs font-medium text-zinc-500 mb-1">ÂØºÊºîÊ®°Âºè</label>
                                                <select value={localDirectorMode} onChange={e => setLocalDirectorMode(e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}>
                                                    <option value="ai">AI ÂØºÊºî (Ëá™Âä®Ë∞ÉÂ∫¶)</option>
                                                    <option value="default">ÈªòËÆ§Ê®°Âºè (@ÁÇπÂêç)</option>
                                                    <option value="werewolf">üê∫ Áãº‰∫∫ÊùÄÊ®°Âºè</option>
                                                </select>
                                            </div>
                                            <div>
                                                <label className="block text-xs font-medium text-zinc-500 mb-1">‰∏ä‰∏ãÊñáÁ™óÂè£Â§ßÂ∞è</label>
                                                <input type="number" min="1" max="100" value={localContextWindowSize} onChange={e => setLocalContextWindowSize(e.target.value)} className={cn("w-full px-3 py-2 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")} />
                                            </div>
                                        </div>
                                        <div className="bg-zinc-100 dark:bg-zinc-800/50 p-4 rounded-lg mb-4 text-sm text-zinc-600 dark:text-zinc-400">
                                            <p className="mb-2 font-bold">ËØ¥ÊòéÔºö{activeDirectorHelp.title}</p>
                                            <p>{activeDirectorHelp.desc}</p>
                                            <ul className="list-disc list-inside mt-2 space-y-1 text-xs opacity-80">
                                                {activeDirectorHelp.tips.map((tip, idx) => (
                                                    <li key={idx}>
                                                        {tip.includes('{agent_descriptions}') ? (
                                                            <>Á≥ªÁªü‰ºöËá™Âä®Â∞Ü <span className="font-mono text-purple-500">{`{agent_descriptions}`}</span> ÊõøÊç¢‰∏∫ÂΩìÂâçÂêØÁî®ÁöÑÊºîÂëòÂàóË°®„ÄÇ</>
                                                        ) : tip}
                                                    </li>
                                                ))}
                                            </ul>
                                        </div>
                                        <div className="flex-1 pb-10 flex flex-col">
                                            {localDirectorMode === 'ai' && (
                                                <>
                                                    <label className="block text-xs font-medium text-zinc-500 mb-1">Ë∞ÉÂ∫¶Êåá‰ª§ (Director Prompt)</label>
                                                    <textarea 
                                                        value={localDirectorRule}
                                                        onChange={e => setLocalDirectorRule(e.target.value)}
                                                        className={cn(
                                                            "flex-1 w-full p-4 rounded border text-sm resize-none leading-relaxed font-mono",
                                                            darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200"
                                                        )}
                                                    />
                                                </>
                                            )}

                                            {localDirectorMode === 'werewolf' && (
                                                <div className="mt-4">
                                                    <label className="block text-xs font-medium text-zinc-500 mb-2">Áãº‰∫∫ÊùÄËßíËâ≤ÊèêÁ§∫ËØç (ÂèØÁºñËæë)</label>
                                                    <div className="grid grid-cols-1 gap-3">
                                                        {Object.entries(localWerewolfRolePrompts || {}).map(([key, value]) => (
                                                            <div key={key} className="p-3 rounded-lg border border-zinc-200 dark:border-zinc-800">
                                                                <div className="text-xs font-bold text-zinc-500 mb-2">{key}</div>
                                                                <textarea
                                                                    value={value}
                                                                    onChange={e => setLocalWerewolfRolePrompts(prev => ({ ...prev, [key]: e.target.value }))}
                                                                    className={cn("w-full p-3 rounded border text-sm resize-none leading-relaxed font-mono", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}
                                                                    rows={3}
                                                                />
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="p-4 border-t border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-950/50 flex justify-between items-center shrink-0">
                            <div className="flex items-center gap-3">
                                <span className="text-xs text-zinc-500">ÂØºÊºî (Ë∞ÉÂ∫¶Âëò) ‰ΩøÁî®ÈÖçÁΩÆ:</span>
                                <select 
                                    value={directorConfigId}
                                    onChange={e => setDirectorConfigId(e.target.value)}
                                    className={cn("text-xs px-2 py-1.5 rounded border max-w-[200px]", darkMode ? "bg-zinc-900 border-zinc-700" : "bg-white border-zinc-300")}
                                >
                                    {localConfigs.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                </select>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={onClose} className="px-4 py-2 text-sm text-zinc-500 hover:text-zinc-700">ÂèñÊ∂à</button>
                                <button onClick={handleSaveAll} className="px-4 py-2 text-sm bg-purple-600 text-white rounded hover:bg-purple-700 flex items-center gap-2 shadow-lg shadow-purple-500/20"><Icons.Save className="w-4 h-4"/> ‰øùÂ≠òÊâÄÊúâÊõ¥Êîπ</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Agent Modal ---
        const AgentModal = ({ open, onClose, agent, configs, prompts, onSave, onDelete, isNew, darkMode }) => {
            const [localAgent, setLocalAgent] = useState({ name: '', avatarColor: 'bg-gray-500', configId: '', promptId: '', model: '' });

            const [availableModels, setAvailableModels] = useState([]);
            const [isChecking, setIsChecking] = useState(false);
            const [isTesting, setIsTesting] = useState(false);
            const [testResult, setTestResult] = useState(null);

            useEffect(() => {
                if (open) {
                    if (agent) {
                        setLocalAgent({ ...agent, model: agent.model || '' });
                    } else if (isNew) {
                        setLocalAgent({
                            id: `agent-${Date.now()}`,
                            name: 'Êñ∞ÊºîÂëò',
                            avatarColor: 'bg-purple-500',
                            configId: configs[0]?.id,
                            promptId: prompts[0]?.id,
                            model: '',
                            enabled: true
                        });
                    }
                    setAvailableModels([]);
                    setTestResult(null);
                }
            }, [open, agent, isNew, configs, prompts]);

            if (!open) return null;
            const colors = ['bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-green-500', 'bg-blue-500', 'bg-purple-500', 'bg-pink-500', 'bg-zinc-500'];

            const activeConfig = configs.find(c => c.id === localAgent.configId);

            const fetchModels = async () => {
                if (!activeConfig || !activeConfig.apiKey) {
                    setTestResult({ type: 'error', msg: "ÂΩìÂâçÈÖçÁΩÆÁº∫Â∞ë API Key" });
                    return;
                }
                setIsChecking(true);
                try {
                    const baseUrl = (activeConfig.baseUrl || '').replace(/\/+$/, '');
                    if (activeConfig.provider === 'google') {
                        const res = await fetch(`${baseUrl}/v1beta/models?key=${activeConfig.apiKey}`);
                        if (!res.ok) throw new Error(res.status);
                        const data = await res.json();
                        const ids = data.models?.filter(m => m.supportedGenerationMethods?.includes("generateContent")).map(m => m.name.replace('models/', '')) || [];
                        setAvailableModels(ids);
                        setTestResult({ type: 'success', msg: `Ëé∑ÂèñÂà∞ ${ids.length} ‰∏™Ê®°Âûã` });
                    } else {
                        let res = await fetch(`${baseUrl}/models`, { headers: { 'Authorization': `Bearer ${activeConfig.apiKey}` } });
                        if (res.status === 404 && !baseUrl.includes('/v1')) res = await fetch(`${baseUrl}/v1/models`, { headers: { 'Authorization': `Bearer ${activeConfig.apiKey}` } });
                        if (!res.ok) throw new Error(res.status);
                        const data = await res.json();
                        const ids = (data.data || []).map(m => m.id).sort();
                        setAvailableModels(ids);
                        setTestResult({ type: 'success', msg: `Ëé∑ÂèñÂà∞ ${ids.length} ‰∏™Ê®°Âûã` });
                    }
                } catch (e) {
                    setTestResult({ type: 'error', msg: `Ëé∑ÂèñÂ§±Ë¥•: ${e.message}` });
                } finally {
                    setIsChecking(false);
                }
            };

            const testModel = async () => {
                const modelToTest = localAgent.model || activeConfig?.model;
                if (!activeConfig?.apiKey || !modelToTest) {
                    setTestResult({ type: 'error', msg: "Áº∫Â∞ëÈÖçÁΩÆÊàñÊ®°Âûã ID" });
                    return;
                }
                setIsTesting(true);
                try {
                    const baseUrl = (activeConfig.baseUrl || '').replace(/\/+$/, '');
                    if (activeConfig.provider === 'google') await callGoogle(activeConfig.apiKey, baseUrl, modelToTest, "Hi");
                    else await callOpenAI(activeConfig.apiKey, baseUrl, modelToTest, "Hi");
                    setTestResult({ type: 'success', msg: `ÊµãËØïÈÄöËøáÔºö${modelToTest}` });
                } catch (e) {
                    setTestResult({ type: 'error', msg: `ÊµãËØïÂ§±Ë¥•: ${e.message}` });
                } finally {
                    setIsTesting(false);
                }
            };

            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 fade-enter">
                    <div className={cn("w-full max-w-sm rounded-xl shadow-2xl p-6", darkMode ? "bg-zinc-900 border border-zinc-800 text-zinc-100" : "bg-white text-zinc-900")}>
                        <h2 className="text-lg font-bold mb-4 flex justify-between items-center">
                            <span>{isNew ? 'Ê∑ªÂä†ÊºîÂëò' : 'ÁºñËæëÊºîÂëò'}</span>
                            {!isNew && <button onClick={() => onDelete(localAgent.id)} className="text-red-500"><Icons.Trash className="w-4 h-4"/></button>}
                        </h2>

                        <div className="space-y-4">
                            <div>
                                <label className="block text-xs font-medium text-zinc-500 mb-1">ÊòæÁ§∫ÂêçÁß∞</label>
                                <input value={localAgent.name} onChange={e => setLocalAgent({...localAgent, name: e.target.value})} className={cn("w-full px-3 py-2 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")} />
                            </div>

                            <div className="grid grid-cols-1 gap-4 p-3 rounded-lg border border-dashed border-zinc-300 dark:border-zinc-700 bg-zinc-50 dark:bg-zinc-900/50">
                                <div>
                                    <label className="block text-xs font-bold text-zinc-500 mb-1 uppercase">Â§ßËÑë (AI Ê®°ÂûãÈÖçÁΩÆ)</label>
                                    <select value={localAgent.configId} onChange={e => setLocalAgent({...localAgent, configId: e.target.value})} className={cn("w-full px-2 py-1.5 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}>
                                        {configs.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                    </select>
                                </div>

                                <div>
                                    <label className="block text-xs font-medium text-zinc-500 mb-1 flex justify-between">
                                        <span>Ê®°ÂûãÂæÆË∞É (ÂèØÈÄâ)</span>
                                        <span className="text-[10px] opacity-70">ÈªòËÆ§: {activeConfig?.model || 'Êú™Áü•'}</span>
                                    </label>
                                    <div className="flex gap-1 mb-1">
                                        <div className="flex-1 relative">
                                            {availableModels.length > 0 ? (
                                                <select 
                                                    value={localAgent.model} 
                                                    onChange={e => setLocalAgent({...localAgent, model: e.target.value})} 
                                                    className={cn("w-full px-2 py-1.5 rounded border text-sm appearance-none", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}
                                                >
                                                    <option value="">Ë∑üÈöèÂÖ®Â±Ä ({activeConfig?.model})</option>
                                                    {availableModels.map(m => <option key={m} value={m}>{m}</option>)}
                                                </select>
                                            ) : (
                                                <input 
                                                    value={localAgent.model} 
                                                    onChange={e => setLocalAgent({...localAgent, model: e.target.value})} 
                                                    placeholder="ÁïôÁ©∫‰ΩøÁî®ÂÖ®Â±ÄÈªòËÆ§ÂÄº" 
                                                    className={cn("w-full px-2 py-1.5 rounded border text-xs", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")} 
                                                />
                                            )}
                                        </div>
                                    </div>
                                    <div className="flex gap-2 justify-end">
                                        <button onClick={fetchModels} disabled={isChecking} className="text-[10px] text-purple-500 hover:underline flex items-center gap-1">
                                            {isChecking ? <Icons.Loader className="w-3 h-3"/> : <Icons.Activity className="w-3 h-3"/>} Ëé∑ÂèñÂàóË°®
                                        </button>
                                        <button onClick={testModel} disabled={isTesting} className="text-[10px] text-green-500 hover:underline flex items-center gap-1">
                                            {isTesting ? <Icons.Loader className="w-3 h-3"/> : <Icons.CheckCircle className="w-3 h-3"/>} ËøûÈÄöÊµãËØï
                                        </button>
                                    </div>
                                    {testResult && (
                                        <div className={cn("text-[10px] mt-1 text-right", testResult.type === 'error' ? "text-red-500" : "text-green-500")}>
                                            {testResult.msg}
                                        </div>
                                    )}
                                </div>

                                <div>
                                    <label className="block text-xs font-bold text-zinc-500 mb-1 uppercase">ÁÅµÈ≠Ç (‰∫∫ËÆæÂâßÊú¨)</label>
                                    <select value={localAgent.promptId} onChange={e => setLocalAgent({...localAgent, promptId: e.target.value})} className={cn("w-full px-2 py-1.5 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}>
                                        {prompts.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
                                    </select>
                                </div>
                            </div>

                            <div>
                                <label className="block text-xs font-medium text-zinc-500 mb-1">Â§¥ÂÉèÈ¢úËâ≤</label>
                                <div className="flex gap-2 flex-wrap">
                                    {colors.map(c => (
                                        <button key={c} onClick={() => setLocalAgent({...localAgent, avatarColor: c})} className={cn("w-6 h-6 rounded-full transition-transform hover:scale-110", c, localAgent.avatarColor === c ? "ring-2 ring-offset-2 ring-white" : "")} />
                                    ))}
                                </div>
                            </div>
                        </div>

                        <div className="mt-6 flex justify-end gap-2">
                            <button onClick={onClose} className="px-3 py-2 text-sm text-zinc-500">ÂèñÊ∂à</button>
                            <button onClick={() => { onSave(localAgent); onClose(); }} className="px-3 py-2 text-sm bg-purple-600 text-white rounded">‰øùÂ≠ò</button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [darkMode, setDarkMode] = useState(true);
            const [configs, setConfigs] = useState(() => safeParse(localStorage.getItem('ww_configs'), DEFAULT_MODEL_CONFIGS));
            const [prompts, setPrompts] = useState(() => safeParse(localStorage.getItem('ww_prompts'), DEFAULT_SYSTEM_PROMPTS));
            const [agents, setAgents] = useState(() => safeParse(localStorage.getItem('ww_agents_v2'), DEFAULT_AGENTS));
            const [directorConfigId, setDirectorConfigId] = useState(() => localStorage.getItem('ww_director_config_id') || configs[0]?.id);
            const [directorRule, setDirectorRule] = useState(() => localStorage.getItem('ww_director_rule') || DEFAULT_DIRECTOR_RULE);
            const [directorMode, setDirectorMode] = useState(() => localStorage.getItem('ww_director_mode') || 'default');
            const [contextWindowSize, setContextWindowSize] = useState(() => Number(localStorage.getItem('ww_context_window')) || 12);
            const [werewolfRolePrompts, setWerewolfRolePrompts] = useState(() => safeParse(localStorage.getItem('ww_role_prompts'), DEFAULT_WEREWOLF_ROLE_PROMPTS));

            const [messages, setMessages] = useState([]);
            const [smallGroupMessages, setSmallGroupMessages] = useState([]);
            const [input, setInput] = useState('');
            const [smallGroupInput, setSmallGroupInput] = useState('');
            const [isAutoPlay, setIsAutoPlay] = useState(false);
            const [directorStatus, setDirectorStatus] = useState(null);
            const [activeSpeakerId, setActiveSpeakerId] = useState(null);
            const [smallGroupMembers, setSmallGroupMembers] = useState(() => safeParse(localStorage.getItem('ww_small_group_members'), []));

            const [werewolfGame, setWerewolfGame] = useState(null);
            const [showWerewolfSetup, setShowWerewolfSetup] = useState(false);
            const [werewolfRevealAll, setWerewolfRevealAll] = useState(false);
            const [werewolfLastPlayers, setWerewolfLastPlayers] = useState([]);
            const [werewolfConfig, setWerewolfConfig] = useState(() => safeParse(localStorage.getItem('ww_config'), {
                wolfCount: 2,
                roles: ['seer', 'witch', 'hunter'],
                playerJoin: true,
                playerName: 'Áé©ÂÆ∂',
                witchSelfSave: false
            }));

            const [showConfig, setShowConfig] = useState(false);
            const [showAgentModal, setShowAgentModal] = useState(false);
            const [editingAgentId, setEditingAgentId] = useState(null);
            const [toasts, setToasts] = useState([]);
            const [smallGroupVisible, setSmallGroupVisible] = useState(true);
            const [smallGroupWidth, setSmallGroupWidth] = useState(() => Number(localStorage.getItem('ww_small_group_width')) || 320);
            const [isDragging, setIsDragging] = useState(false);
            const messagesEndRef = useRef(null);
            const smallGroupEndRef = useRef(null);
            const autoPlayRef = useRef(isAutoPlay);
            const autoPlayTimeoutRef = useRef(null);
            const messagesRef = useRef(messages);
            const smallGroupMessagesRef = useRef(smallGroupMessages);
            const speakingLockRef = useRef(false);
            const werewolfGameRef = useRef(werewolfGame);

            useEffect(() => {
                localStorage.setItem('ww_configs', JSON.stringify(configs));
                localStorage.setItem('ww_prompts', JSON.stringify(prompts));
                localStorage.setItem('ww_agents_v2', JSON.stringify(agents));
                localStorage.setItem('ww_director_config_id', directorConfigId);
                localStorage.setItem('ww_director_rule', directorRule);
                localStorage.setItem('ww_director_mode', directorMode);
                localStorage.setItem('ww_context_window', String(contextWindowSize));
                localStorage.setItem('ww_small_group_members', JSON.stringify(smallGroupMembers));
                localStorage.setItem('ww_small_group_width', String(smallGroupWidth));
                localStorage.setItem('ww_config', JSON.stringify(werewolfConfig));
                localStorage.setItem('ww_role_prompts', JSON.stringify(werewolfRolePrompts));
            }, [configs, prompts, agents, directorConfigId, directorRule, directorMode, contextWindowSize, smallGroupMembers, smallGroupWidth, werewolfConfig, werewolfRolePrompts]);

            useEffect(() => {
                if (darkMode) document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
            }, [darkMode]);

            useEffect(() => { messagesRef.current = messages; }, [messages]);
            useEffect(() => { smallGroupMessagesRef.current = smallGroupMessages; }, [smallGroupMessages]);
            useEffect(() => {
                werewolfGameRef.current = werewolfGame;
                if (werewolfGame?.players?.length) {
                    setWerewolfLastPlayers(werewolfGame.players.map(p => ({ ...p })));
                }
            }, [werewolfGame]);

            useEffect(() => {
                if (!isDragging) return;
                const handleMove = (event) => {
                    const next = Math.min(420, Math.max(240, window.innerWidth - event.clientX));
                    setSmallGroupWidth(next);
                };
                const handleUp = () => setIsDragging(false);
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                };
            }, [isDragging]);

            useEffect(() => {
                autoPlayRef.current = isAutoPlay;
                if (!isAutoPlay && autoPlayTimeoutRef.current) {
                    clearTimeout(autoPlayTimeoutRef.current);
                    autoPlayTimeoutRef.current = null;
                }
            }, [isAutoPlay]);

            useEffect(() => messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }), [messages, directorStatus, activeSpeakerId]);
            useEffect(() => smallGroupEndRef.current?.scrollIntoView({ behavior: 'smooth' }), [smallGroupMessages, activeSpeakerId]);

            const addToast = (msg, type) => {
                const id = Date.now();
                setToasts(p => [...p, { id, msg, type }]);
                setTimeout(() => setToasts(p => p.filter(t => t.id !== id)), 3000);
            };

            const Markdown = ({ content }) => {
                const safeContent = String(content ?? '');
                const html = useMemo(() => marked.parse(safeContent), [safeContent]);
                return <div className="prose prose-sm dark:prose-invert max-w-none break-words" dangerouslySetInnerHTML={{ __html: html }} />;
            };

            const getEnabledAgents = () => agents.filter(a => a.enabled);
            const getSmallGroupAgents = () => agents.filter(a => a.enabled && smallGroupMembers.includes(a.id));
            const formatTime = (timestamp) => new Date(timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

            const copyToClipboard = async (text) => {
                if (!text) return;
                try {
                    await navigator.clipboard.writeText(text);
                    addToast('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
                } catch (e) {
                    addToast('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÊùÉÈôê', 'error');
                }
            };

            const clearChat = (scope, options = {}) => {
                const { confirm = true, pauseGame = true, toast = true } = options;
                const ask = (text) => {
                    try {
                        if (!confirm) return true;
                        if (typeof window !== 'undefined' && typeof window.confirm === 'function') return window.confirm(text);
                    } catch (e) {}
                    return true;
                };
                if (scope === 'all') {
                    if (!ask('Á°ÆÂÆöÊ∏ÖÁ©∫Â§ßÁæ§ÂíåÂ∞èÁæ§ËÅäÂ§©ËÆ∞ÂΩïÔºü')) return;
                    setMessages([]);
                    setSmallGroupMessages([]);
                    messagesRef.current = [];
                    smallGroupMessagesRef.current = [];
                } else {
                    const label = scope === 'small' ? 'Â∞èÁæ§' : 'Â§ßÁæ§';
                    if (!ask(`Á°ÆÂÆöÊ∏ÖÁ©∫${label}ËÅäÂ§©ËÆ∞ÂΩïÔºü`)) return;
                    if (scope === 'small') {
                        setSmallGroupMessages([]);
                        smallGroupMessagesRef.current = [];
                    } else {
                        setMessages([]);
                        messagesRef.current = [];
                    }
                }

                if (autoPlayTimeoutRef.current) {
                    clearTimeout(autoPlayTimeoutRef.current);
                    autoPlayTimeoutRef.current = null;
                }

                setActiveSpeakerId(null);
                speakingLockRef.current = false;

                if (toast) {
                    if (directorMode === 'werewolf' && werewolfGameRef.current && pauseGame) {
                        setWerewolfGame(prev => prev ? { ...prev, paused: true } : prev);
                        addToast('Â∑≤Ê∏ÖÁ©∫ËÅäÂ§©Âπ∂ÊöÇÂÅúÊ∏∏Êàè', 'success');
                    } else {
                        addToast('Â∑≤Ê∏ÖÁ©∫ËÅäÂ§©', 'success');
                    }
                } else if (directorMode === 'werewolf' && werewolfGameRef.current && pauseGame) {
                    setWerewolfGame(prev => prev ? { ...prev, paused: true } : prev);
                }
            };

            const exportChat = (format, scope = 'all') => {
                const mainHistory = messagesRef.current;
                const smallHistory = smallGroupMessagesRef.current;
                const exportList = scope === 'all'
                    ? mergeHistories(mainHistory, smallHistory)
                    : (scope === 'small' ? smallHistory : mainHistory);

                if (exportList.length === 0) {
                    addToast('Ê≤°ÊúâÂèØÂØºÂá∫ÁöÑÂÜÖÂÆπ', 'error');
                    return;
                }

                const now = new Date();
                const safeTime = now.toISOString().replace(/[:.]/g, '-');
                const fileBase = `werewolf-export-${scope}-${safeTime}`;

                let content = '';
                let mime = 'text/plain';
                let ext = 'txt';

                if (format === 'json') {
                    content = JSON.stringify(exportList, null, 2);
                    mime = 'application/json';
                    ext = 'json';
                } else if (format === 'md') {
                    ext = 'md';
                    mime = 'text/markdown';
                    content = exportList.map(m => {
                        const roomTag = m.room === 'small' ? '[Â∞èÁæ§]' : '[Â§ßÁæ§]';
                        const name = m.role === 'user' ? '‰Ω†' : (m.senderName || 'Êú™Áü•');
                        const time = m.time ? ` ${m.time}` : '';
                        return `- ${roomTag} ${name}${time}: ${m.content}`;
                    }).join('\n');
                } else {
                    ext = 'txt';
                    mime = 'text/plain';
                    content = exportList.map(m => {
                        const roomTag = m.room === 'small' ? '[Â∞èÁæ§]' : '[Â§ßÁæ§]';
                        const name = m.role === 'user' ? '‰Ω†' : (m.senderName || 'Êú™Áü•');
                        const time = m.time ? ` ${m.time}` : '';
                        return `${roomTag} ${name}${time}: ${m.content}`;
                    }).join('\n');
                }

                const blob = new Blob([content], { type: `${mime};charset=utf-8` });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileBase}.${ext}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const mergeHistories = (mainHistory, smallHistory) => {
                const merged = [...mainHistory, ...smallHistory].map(m => ({ ...m }));
                return merged.sort((a, b) => (a.id || 0) - (b.id || 0));
            };

            const getNextAgentByOrder = (enabledAgents, history) => {
                if (enabledAgents.length === 0) return null;
                const lastAgentMsg = [...history].reverse().find(m => m.role === 'assistant' && m.senderId);
                if (!lastAgentMsg) return enabledAgents[0];
                const lastIdx = enabledAgents.findIndex(a => a.id === lastAgentMsg.senderId);
                if (lastIdx === -1) return enabledAgents[0];
                return enabledAgents[(lastIdx + 1) % enabledAgents.length];
            };

            const findMentionedAgent = (text, enabledAgents) => {
                if (!text) return null;
                const normalized = text.trim();
                return enabledAgents.find(a => normalized.includes(`@${a.name}`));
            };

            const hasMentionAll = (text) => {
                if (!text) return false;
                return text.includes('@ÊâÄÊúâ‰∫∫') || text.toLowerCase().includes('@all');
            };

            const formatContextMessages = (history, tag) => history.map(m => ({
                role: m.role === 'user' ? 'user' : 'assistant',
                content: `${tag}${m.senderName ? m.senderName + ': ' : ''}${m.content}`
            }));

            const getCombinedContextMessages = () => {
                const mainHistory = messagesRef.current;
                const smallHistory = smallGroupMessagesRef.current;
                const combined = mergeHistories(mainHistory, smallHistory).slice(-contextWindowSize);
                return combined.map(m => ({
                    role: m.role === 'user' ? 'user' : 'assistant',
                    content: `${m.room === 'small' ? '[Â∞èÁæ§] ' : '[Â§ßÁæ§] '}${m.senderName ? m.senderName + ': ' : ''}${m.content}`
                }));
            };

            const parseJSONFromText = (rawText) => {
                if (!rawText) return null;
                const trimmed = rawText.trim();
                const tryParse = (candidate) => {
                    try { return JSON.parse(candidate); } catch (e) { return null; }
                };
                if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
                    const parsed = tryParse(trimmed);
                    if (parsed) return parsed;
                }
                const codeBlockMatch = trimmed.match(/```json\s*([\s\S]*?)\s*```/i);
                if (codeBlockMatch) {
                    const parsed = tryParse(codeBlockMatch[1]);
                    if (parsed) return parsed;
                }
                const jsonMatch = trimmed.match(/\{[\s\S]*\}/);
                if (jsonMatch) return tryParse(jsonMatch[0]);
                return null;
            };

            const createSystemMsg = (content, room = 'main') => ({
                id: Date.now(),
                role: 'system',
                content,
                room,
                time: formatTime(Date.now()),
                isSystem: true
            });

            const createUserMsg = (content, room = 'main', options = {}) => ({
                id: Date.now(),
                role: 'user',
                content,
                room,
                time: formatTime(Date.now()),
                isAction: !!options.isAction,
                actionType: options.actionType || null
            });

            const createAssistantMsg = (content, sender, room = 'main') => ({
                id: Date.now() + Math.random(),
                role: 'assistant',
                senderId: sender?.id,
                senderName: sender?.name,
                avatarColor: sender?.avatarColor,
                content,
                room,
                time: formatTime(Date.now())
            });

            const isGamePaused = (game) => !game || game.paused || werewolfGameRef.current?.paused;

            const tallyVotes = (votes, players) => {
                const voteCount = {};
                Object.values(votes || {}).forEach(targetId => {
                    if (!targetId || targetId === 'abstain') return;
                    voteCount[targetId] = (voteCount[targetId] || 0) + 1;
                });
                let maxVotes = 0;
                let topTargets = [];
                Object.entries(voteCount).forEach(([id, count]) => {
                    if (count > maxVotes) {
                        maxVotes = count;
                        topTargets = [players.find(p => p.id === id)].filter(Boolean);
                    } else if (count === maxVotes) {
                        const target = players.find(p => p.id === id);
                        if (target) topTargets.push(target);
                    }
                });
                return { voteCount, maxVotes, topTargets };
            };

            const getRoleCountsSummary = (game) => {
                const g = game || werewolfGameRef.current;
                if (!g?.players?.length) return '';
                const counts = g.players.reduce((acc, p) => {
                    acc[p.role] = (acc[p.role] || 0) + 1;
                    return acc;
                }, {});
                const wolfCount = counts.wolf || 0;
                const villagerCount = counts.villager || 0;
                const specialRoles = Object.entries(counts).filter(([role]) => !['wolf', 'villager'].includes(role));
                const specialText = specialRoles.length
                    ? specialRoles.map(([role, count]) => `${WEREWOLF_ROLES?.[role]?.name || role}√ó${count}`).join('„ÄÅ')
                    : 'Êó†';
                return `Êú¨Â±ÄËßíËâ≤ÈÖçÁΩÆÔºöÁãº‰∫∫ ${wolfCount} ‰∫∫ÔºõÁ•ûËÅåÔºö${specialText}ÔºõÊùëÊ∞ë ${villagerCount} ‰∫∫„ÄÇ`;
            };

            const areAllVotesIn = (game) => {
                const voters = game.players.filter(p => p.alive && p.canVote);
                return voters.every(p => (p.isHuman ? game.votes?.player : game.votes?.[p.id]));
            };

            const getMentionedTarget = (text, targets) => {
                if (!text || !targets?.length) return null;
                const sorted = [...targets].sort((a, b) => (b.name?.length || 0) - (a.name?.length || 0));
                return sorted.find(t => text.includes(`@${t.name}`) || text.includes(t.name)) || null;
            };

            const parseVoteDecision = (rawText, candidates) => {
                if (!rawText) return null;
                const parsed = parseJSONFromText(rawText);
                const targetName = parsed?.target_name || parsed?.target || parsed?.name;
                if (targetName) {
                    return candidates.find(c => c.name === targetName) || getMentionedTarget(targetName, candidates);
                }
                return getMentionedTarget(rawText.trim(), candidates);
            };

            const getMostMentionedTarget = (history, candidates) => {
                if (!history?.length || !candidates?.length) return null;
                const usableHistory = history.filter(m => !m?.isSystem && m?.role !== 'system');
                const counts = new Map();
                candidates.forEach(c => counts.set(c.id, 0));
                usableHistory.forEach(m => {
                    const target = getMentionedTarget(m.content || '', candidates);
                    if (target) counts.set(target.id, (counts.get(target.id) || 0) + 1);
                });
                let best = null;
                let max = 0;
                counts.forEach((count, id) => {
                    if (count > max) {
                        max = count;
                        best = candidates.find(c => c.id === id);
                    }
                });
                return best;
            };

            const callLLMOnce = (messages, config) => new Promise(resolve => {
                let full = '';
                callLLM(
                    messages,
                    config,
                    (chunk) => { full += chunk; },
                    () => resolve(full),
                    () => resolve('')
                );
            });

            const decideAIVote = async (agent, playerRole, history, candidates, room, phaseLabel) => {
                const config = configs.find(c => c.id === agent.configId);
                const prompt = prompts.find(p => p.id === agent.promptId);
                if (!config || !prompt) return null;

                const effectiveConfig = { ...config, model: agent.model || config.model };
                const candidateNames = candidates.map(c => c.name).join('„ÄÅ');
                const rolePrompt = werewolfRolePrompts[playerRole] || '';
                const roleSummary = getRoleCountsSummary(werewolfGameRef.current);
                const system = `${prompt.content}\n${rolePrompt}\n${roleSummary}\n‰Ω†Ê≠£Âú®Áé©Áãº‰∫∫ÊùÄ„ÄÇÁé∞Âú®ÊòØ${phaseLabel}ÔºåËØ∑Ê†πÊçÆ‰∏ä‰∏ãÊñáÂÜ≥ÂÆöÊäïÁ•®ÁõÆÊ†á„ÄÇÂèØÈÄâÁõÆÊ†áÔºö${candidateNames}„ÄÇ\n‰ªÖËøîÂõûJSONÔºö{"target_name":"ÂêçÂ≠ó","reason":"ÁêÜÁî±"}`;

                const contextMessages = history.slice(-contextWindowSize).map(m => ({
                    role: m.role === 'user' ? 'user' : 'assistant',
                    content: `${m.senderName ? m.senderName + ': ' : ''}${m.content}`
                }));

                const raw = await callLLMOnce([{ role: 'system', content: system }, ...contextMessages], effectiveConfig);
                return parseVoteDecision(raw, candidates);
            };

            const triggerAgentSequence = async (agentList, history, reason, room) => {
                let currentHistory = [...history];
                for (const agent of agentList) {
                    if (speakingLockRef.current) return;
                    const responseText = await triggerAgentResponse(agent, currentHistory, reason, room);
                    currentHistory = [...currentHistory, { id: Date.now(), role: 'assistant', senderId: agent.id, senderName: agent.name, content: responseText, room, time: formatTime(Date.now()) }];
                }
            };

            const parseDirectorDecision = (rawText) => parseJSONFromText(rawText);

            const runDirectorCycle = async (history) => {
                if (activeSpeakerId || speakingLockRef.current) return;

                const directorConfig = configs.find(c => c.id === directorConfigId);
                const enabledAgents = getEnabledAgents();
                if (enabledAgents.length === 0) return;

                if (directorMode === 'default') {
                    const lastUserMsg = [...history].reverse().find(m => m.role === 'user');
                    if (hasMentionAll(lastUserMsg?.content)) {
                        await triggerAgentSequence(enabledAgents, history, 'Ë¢´@ÊâÄÊúâ‰∫∫ÁÇπÂêç', 'main');
                        return;
                    }
                    const mentionedAgent = findMentionedAgent(lastUserMsg?.content, enabledAgents);
                    if (mentionedAgent) {
                        triggerAgentResponse(mentionedAgent, history, 'Ë¢´@ÁÇπÂêç', 'main');
                        return;
                    }

                    if (autoPlayRef.current) {
                        const roomHistory = messagesRef.current;
                        const nextAgent = getNextAgentByOrder(enabledAgents, roomHistory);
                        if (nextAgent) triggerAgentResponse(nextAgent, roomHistory, 'È°∫Â∫è‰∫íÊÄº', 'main');
                    }
                    return;
                }

                if (!directorConfig?.apiKey) {
                    addToast("ÂØºÊºîÈÖçÁΩÆÊó†ÊïàÊàñÁº∫Â∞ëKey", "error");
                    setIsAutoPlay(false);
                    return;
                }

                setDirectorStatus('thinking');

                const agentDescriptions = enabledAgents.map(a => {
                    const prompt = prompts.find(p => p.id === a.promptId);
                    return `- ID: ${a.id}, ÂêçÂ≠ó: ${a.name}, ‰∫∫ËÆæ: ${prompt ? prompt.content.substring(0, 100) : 'Êú™Áü•'}`;
                }).join('\n');

                const finalDirectorPrompt = directorRule.replace('{agent_descriptions}', agentDescriptions);

                const contextMsgs = getCombinedContextMessages();

                try {
                    let fullResponse = "";
                    await callLLM(
                        [{ role: "system", content: finalDirectorPrompt }, ...contextMsgs],
                        directorConfig,
                        (chunk) => fullResponse += chunk,
                        () => {
                            setDirectorStatus(null);
                            const decision = parseDirectorDecision(fullResponse);
                            if (decision?.next_speaker_id) {
                                const agent = agents.find(a => a.id === decision.next_speaker_id && a.enabled);
                                if (agent) triggerAgentResponse(agent, history, decision.reason || 'ÂØºÊºîË∞ÉÂ∫¶', 'main');
                                return;
                            }
                            if (autoPlayRef.current) {
                                const fallbackAgent = getNextAgentByOrder(enabledAgents, history);
                                if (fallbackAgent) {
                                    addToast("ÂØºÊºîËß£ÊûêÂ§±Ë¥•ÔºåÊîπÁî®È°∫Â∫èÊ®°Âºè", "error");
                                    triggerAgentResponse(fallbackAgent, history, 'Ëß£ÊûêÂ§±Ë¥•ÂõûÈÄÄ', 'main');
                                }
                            } else {
                                setIsAutoPlay(false);
                            }
                        },
                        (err) => { addToast(`ÂØºÊºîÂá∫Èîô: ${err}`, 'error'); setDirectorStatus(null); }
                    );
                } catch (e) { setDirectorStatus(null); }

            };

            const runSmallGroupCycle = async (history) => {
                if (activeSpeakerId || speakingLockRef.current) return;
                const enabledAgents = getSmallGroupAgents();
                if (enabledAgents.length === 0) return;

                if (directorMode === 'default') {
                    const lastUserMsg = [...history].reverse().find(m => m.role === 'user');
                    if (hasMentionAll(lastUserMsg?.content)) {
                        await triggerAgentSequence(enabledAgents, history, 'Ë¢´@ÊâÄÊúâ‰∫∫ÁÇπÂêç', 'small');
                        return;
                    }
                    const mentionedAgent = findMentionedAgent(lastUserMsg?.content, enabledAgents);
                    if (mentionedAgent) {
                        triggerAgentResponse(mentionedAgent, history, 'Ë¢´@ÁÇπÂêç', 'small');
                        return;
                    }
                    if (autoPlayRef.current) {
                        const roomHistory = smallGroupMessagesRef.current;
                        const nextAgent = getNextAgentByOrder(enabledAgents, roomHistory);
                        if (nextAgent) triggerAgentResponse(nextAgent, roomHistory, 'È°∫Â∫è‰∫íÊÄº', 'small');
                    }
                    return;
                }

                const directorConfig = configs.find(c => c.id === directorConfigId);
                if (!directorConfig?.apiKey) {
                    addToast("ÂØºÊºîÈÖçÁΩÆÊó†ÊïàÊàñÁº∫Â∞ëKey", "error");
                    setIsAutoPlay(false);
                    return;
                }

                setDirectorStatus('thinking');
                const agentDescriptions = enabledAgents.map(a => {
                    const prompt = prompts.find(p => p.id === a.promptId);
                    return `- ID: ${a.id}, ÂêçÂ≠ó: ${a.name}, ‰∫∫ËÆæ: ${prompt ? prompt.content.substring(0, 100) : 'Êú™Áü•'}`;
                }).join('\n');

                const finalDirectorPrompt = directorRule.replace('{agent_descriptions}', agentDescriptions);
                const contextMsgs = getCombinedContextMessages();

                try {
                    let fullResponse = "";
                    await callLLM(
                        [{ role: "system", content: finalDirectorPrompt }, ...contextMsgs],
                        directorConfig,
                        (chunk) => fullResponse += chunk,
                        () => {
                            setDirectorStatus(null);
                            const decision = parseDirectorDecision(fullResponse);
                            if (decision?.next_speaker_id) {
                                const agent = enabledAgents.find(a => a.id === decision.next_speaker_id);
                                if (agent) triggerAgentResponse(agent, history, decision.reason || 'ÂØºÊºîË∞ÉÂ∫¶', 'small');
                                return;
                            }
                            if (autoPlayRef.current) {
                                const fallbackAgent = getNextAgentByOrder(enabledAgents, history);
                                if (fallbackAgent) {
                                    addToast("ÂØºÊºîËß£ÊûêÂ§±Ë¥•ÔºåÊîπÁî®È°∫Â∫èÊ®°Âºè", "error");
                                    triggerAgentResponse(fallbackAgent, history, 'Ëß£ÊûêÂ§±Ë¥•ÂõûÈÄÄ', 'small');
                                }
                            } else {
                                setIsAutoPlay(false);
                            }
                        },
                        (err) => { addToast(`ÂØºÊºîÂá∫Èîô: ${err}`, 'error'); setDirectorStatus(null); }
                    );
                } catch (e) { setDirectorStatus(null); }
            };

            const triggerAgentResponse = async (agent, history, reason, room = 'main') => {
                const config = configs.find(c => c.id === agent.configId);
                const prompt = prompts.find(p => p.id === agent.promptId);

                if (!config || !prompt) return addToast(`${agent.name} ÈÖçÁΩÆ‰∏çÂÆåÊï¥`, 'error');
                if (directorMode === 'werewolf' && werewolfGameRef.current?.paused) return '';

                if (speakingLockRef.current) return '';
                speakingLockRef.current = true;
                setActiveSpeakerId(agent.id);

                const shouldShareContext = smallGroupMembers.includes(agent.id);
                const contextBase = shouldShareContext ? mergeHistories(messagesRef.current, smallGroupMessagesRef.current) : history;
                const contextMessages = contextBase.slice(-contextWindowSize).map(m => ({
                    role: m.role === 'user' ? 'user' : (m.senderId === agent.id ? 'assistant' : 'user'),
                    content: `${m.room === 'small' ? '[Â∞èÁæ§] ' : '[Â§ßÁæ§] '}${m.senderId && m.senderId !== agent.id ? `[${m.senderName}]: ${m.content}` : m.content}`
                }));

                const systemMsg = { role: 'system', content: `${prompt.content}\n\n(ÂΩìÂâçÊÉÖÂ¢É: ${reason || 'ËΩÆÂà∞‰Ω†ÂèëË®Ä'})` };

                const effectiveConfig = { ...config, model: agent.model || config.model };

                const newMsgId = Date.now();
                const setRoomMessages = room === 'small' ? setSmallGroupMessages : setMessages;
                setRoomMessages(prev => [...prev, { id: newMsgId, role: 'assistant', senderId: agent.id, senderName: agent.name, avatarColor: agent.avatarColor, content: '', isThinking: true, room, time: formatTime(Date.now()) }]);

                let responseText = "";
                await callLLM(
                    [systemMsg, ...contextMessages],
                    effectiveConfig,
                    (chunk) => {
                        responseText += chunk;
                        setRoomMessages(prev => prev.map(m => m.id === newMsgId ? { ...m, content: responseText, isThinking: false } : m));
                    },
                    () => {
                        setActiveSpeakerId(null);
                        speakingLockRef.current = false;
                        if (autoPlayRef.current) {
                            autoPlayTimeoutRef.current = setTimeout(() => {
                                if (autoPlayRef.current) {
                                    const nextHistory = [...history, { role: 'assistant', senderId: agent.id, senderName: agent.name, content: responseText, room, time: formatTime(Date.now()) }];
                                    if (room === 'small') runSmallGroupCycle(nextHistory);
                                    else runDirectorCycle(nextHistory);
                                }
                            }, 2000);
                        }
                    },
                    (err) => { setActiveSpeakerId(null); speakingLockRef.current = false; addToast(`ÂèëË®ÄÂ§±Ë¥•: ${err}`, 'error'); }
                );
                return responseText;
            };

            const handleUserSend = () => {
                if (!input.trim()) return;

                if (directorMode === 'werewolf' && werewolfGame) {
                    const handled = handleWerewolfPlayerAction(input, 'main');
                    if (!handled) {
                        const newMsg = createUserMsg(input, 'main');
                        setMessages(prev => [...prev, newMsg]);
                    }
                    setInput('');
                    return;
                }

                const newMsg = createUserMsg(input, 'main');
                const newHistory = [...messages, newMsg];
                setMessages(newHistory);
                setInput('');
                setTimeout(() => runDirectorCycle(newHistory), 500);
            };

            const handleSmallGroupSend = () => {
                if (!smallGroupInput.trim()) return;
                if (directorMode === 'werewolf' && werewolfGame) {
                    const handled = handleWerewolfPlayerAction(smallGroupInput, 'small');
                    if (handled) {
                        setSmallGroupInput('');
                        return;
                    }
                }
                const newMsg = createUserMsg(smallGroupInput, 'small');
                const newHistory = [...smallGroupMessages, newMsg];
                setSmallGroupMessages(newHistory);
                setSmallGroupInput('');
                setTimeout(() => runSmallGroupCycle(newHistory), 500);
            };

            const quickAt = (name, room) => {
                const token = `@${name} `;
                if (room === 'small') setSmallGroupInput(prev => (prev || '') + token);
                else setInput(prev => (prev || '') + token);
            };

            const toggleSmallGroupMember = (agentId) => {
                setSmallGroupMembers(prev => prev.includes(agentId) ? prev.filter(id => id !== agentId) : [...prev, agentId]);
            };

            const handleSaveAgent = (updated) => {
                setAgents(prev => {
                    const exists = prev.find(a => a.id === updated.id);
                    if (exists) return prev.map(a => a.id === updated.id ? updated : a);
                    return [...prev, updated];
                });
            };

            const handleDeleteAgent = (id) => {
                setAgents(prev => prev.filter(a => a.id !== id));
                setShowAgentModal(false);
            };

            // ========== Áãº‰∫∫ÊùÄÊ∏∏ÊàèÈÄªËæë ==========
            const WEREWOLF_ROLES = {
                wolf: { name: 'Áãº‰∫∫', emoji: 'üê∫', team: 'wolf', desc: 'ÊØèÊôöÂèØ‰ª•ÊùÄÊ≠ª‰∏ÄÂêçÁé©ÂÆ∂' },
                villager: { name: 'ÊùëÊ∞ë', emoji: 'üë®‚Äçüåæ', team: 'village', desc: 'Ê≤°ÊúâÁâπÊÆäËÉΩÂäõÔºå‰æùÈù†ÊäïÁ•®ÊâæÂá∫Áãº‰∫∫' },
                seer: { name: 'È¢ÑË®ÄÂÆ∂', emoji: 'üîÆ', team: 'village', desc: 'ÊØèÊôöÂèØ‰ª•Êü•È™å‰∏ÄÂêçÁé©ÂÆ∂ÁöÑË∫´‰ªΩ' },
                witch: { name: 'Â•≥Â∑´', emoji: 'üßô‚Äç‚ôÄÔ∏è', team: 'village', desc: 'Êúâ‰∏ÄÁì∂Ëß£ËçØÂíå‰∏ÄÁì∂ÊØíËçØ' },
                hunter: { name: 'Áåé‰∫∫', emoji: 'üèπ', team: 'village', desc: 'Ê≠ª‰∫°Êó∂ÂèØ‰ª•Â∏¶Ëµ∞‰∏ÄÂêçÁé©ÂÆ∂' },
                guard: { name: 'ÂÆàÂç´', emoji: 'üõ°Ô∏è', team: 'village', desc: 'ÊØèÊôöÂèØ‰ª•ÂÆàÊä§‰∏ÄÂêçÁé©ÂÆ∂' },
                idiot: { name: 'ÁôΩÁó¥', emoji: 'ü§™', team: 'village', desc: 'Ë¢´ÊäïÁ•®Âá∫Â±ÄÂêéÂèØ‰ª•ÁøªÁâåÂÖçÊ≠ªÔºå‰ΩÜÂ§±ÂéªÊäïÁ•®ÊùÉ' }
            };

            const startWerewolfGame = () => {
                const enabledAgents = getEnabledAgents();
                const totalPlayers = werewolfConfig.playerJoin ? enabledAgents.length + 1 : enabledAgents.length;

                if (totalPlayers < 4) {
                    addToast('Ëá≥Â∞ëÈúÄË¶Å4ÂêçÁé©ÂÆ∂ÊâçËÉΩÂºÄÂßãÊ∏∏Êàè', 'error');
                    return;
                }

                const roles = [];
                for (let i = 0; i < werewolfConfig.wolfCount; i++) roles.push('wolf');
                werewolfConfig.roles.forEach(r => roles.push(r));
                while (roles.length < totalPlayers) roles.push('villager');
                while (roles.length > totalPlayers) roles.pop();

                const shuffledRoles = [...roles].sort(() => Math.random() - 0.5);

                const players = [];
                let roleIndex = 0;

                if (werewolfConfig.playerJoin) {
                    players.push({
                        id: 'player',
                        name: werewolfConfig.playerName || 'Áé©ÂÆ∂',
                        role: shuffledRoles[roleIndex++],
                        isHuman: true,
                        alive: true,
                        canVote: true
                    });
                }

                enabledAgents.forEach(agent => {
                    players.push({
                        id: agent.id,
                        name: agent.name,
                        role: shuffledRoles[roleIndex++],
                        isHuman: false,
                        alive: true,
                        canVote: true,
                        avatarColor: agent.avatarColor
                    });
                });

                const wolfIds = players.filter(p => p.role === 'wolf' && !p.isHuman).map(p => p.id);
                const humanWolf = players.find(p => p.role === 'wolf' && p.isHuman);
                setSmallGroupMembers(humanWolf ? [...wolfIds, 'player'] : wolfIds);

                const gameState = {
                    phase: 'night',
                    day: 1,
                    players,
                    currentSpeaker: 0,
                    dayStartIndex: 0,
                    daySpeechOrder: [],
                    daySpeechPos: 0,
                    nightActions: {},
                    witchPotion: { heal: true, poison: true },
                    lastGuarded: null,
                    deadTonight: [],
                    voteTarget: null,
                    gameLog: [],
                    paused: false,
                    seerResult: {},
                    idiotRevealed: false,
                    deathLog: {},
                    lastWordsQueue: [],
                    awaitingLastWords: null,
                    pendingPostLastWords: null,
                    awaitingGuard: false,
                    awaitingSeer: false,
                    pendingHunterShot: null,
                    awaitingWitch: false,
                    awaitingWolf: false,
                    awaitingDaySpeech: null,
                    nightStage: 'guard'
                };

                setWerewolfGame(gameState);
                setShowWerewolfSetup(false);
                clearChat('all', { confirm: false, pauseGame: false, toast: false });

                const playerRole = players.find(p => p.isHuman);
                const roleInfo = playerRole ? WEREWOLF_ROLES[playerRole.role] : null;

                let startMsg = `üê∫ **Áãº‰∫∫ÊùÄÊ∏∏ÊàèÂºÄÂßãÔºÅ** üê∫\n\n`;
                startMsg += `Êú¨Â±ÄÂÖ± ${totalPlayers} ÂêçÁé©ÂÆ∂Ôºå${werewolfConfig.wolfCount} Âè™Áãº‰∫∫„ÄÇ\n\n`;
                startMsg += `**Áé©ÂÆ∂ÂàóË°®Ôºö**\n`;
                players.forEach((p, i) => {
                    startMsg += `${i + 1}. ${p.name}${p.isHuman ? ' (‰Ω†)' : ''}\n`;
                });

                if (playerRole) {
                    startMsg += `\n---\n\nüé≠ **‰Ω†ÁöÑË∫´‰ªΩÊòØÔºö${roleInfo.emoji} ${roleInfo.name}**\n`;
                    startMsg += `> ${roleInfo.desc}\n`;
                    if (playerRole.role === 'wolf') {
                        const teammates = players.filter(p => p.role === 'wolf' && p.id !== 'player');
                        if (teammates.length > 0) {
                            startMsg += `\n‰Ω†ÁöÑÁãºÈòüÂèãÔºö${teammates.map(t => t.name).join('„ÄÅ')}\n`;
                            startMsg += `ÔºàÂ∞èÁæ§ÊòØÁãº‰∫∫ÁßÅËÅäÈ¢ëÈÅìÔºâ`;
                        }
                    }
                }

                startMsg += `\n\n---\n\nüåô **Á¨¨ 1 Â§úÈôç‰∏¥ÔºåËØ∑Èó≠Áúº...**`;

                setMessages([{ id: Date.now(), role: 'system', content: startMsg, room: 'main', time: formatTime(Date.now()), isSystem: true }]);

                if (wolfIds.length > 0) {
                    const wolfNames = players.filter(p => p.role === 'wolf').map(p => p.name);
                    setSmallGroupMessages([{
                        id: Date.now() + 1,
                        role: 'system',
                        content: `üê∫ **Áãº‰∫∫È¢ëÈÅì**\n\nÁãºÈòüÊàêÂëòÔºö${wolfNames.join('„ÄÅ')}\n\nËØ∑Âú®ËøôÈáåËÆ®ËÆ∫‰ªäÊôöË¶ÅÊùÄË∞Å„ÄÇ`,
                        room: 'small',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);
                }

                setTimeout(() => runWerewolfNight(gameState), 2000);
            };

            const NIGHT_PHASES = ['guard', 'wolf', 'witch', 'seer', 'resolve'];
            const getNextNightStage = (stage) => {
                const idx = NIGHT_PHASES.indexOf(stage || 'guard');
                return NIGHT_PHASES[Math.min(idx + 1, NIGHT_PHASES.length - 1)] || 'resolve';
            };

            const chooseGuardTarget = (game, candidates) => {
                const seer = game.players.find(p => p.alive && p.role === 'seer');
                const mostMentioned = getMostMentionedTarget(messagesRef.current, candidates);
                if (seer && candidates.some(c => c.id === seer.id) && Math.random() < 0.5) return seer;
                return mostMentioned || candidates[Math.floor(Math.random() * candidates.length)];
            };

            const chooseSeerTarget = (game, candidates) => {
                const mostMentioned = getMostMentionedTarget(messagesRef.current, candidates);
                return mostMentioned || candidates[Math.floor(Math.random() * candidates.length)];
            };

            const shouldWitchHeal = (game, target) => {
                if (!target) return false;
                const important = ['seer', 'guard', 'witch', 'hunter'];
                const isImportant = important.includes(target.role);
                const mostMentioned = getMostMentionedTarget(messagesRef.current, [target]);
                if (isImportant) return true;
                if (mostMentioned) return true;
                return Math.random() < 0.35;
            };

            const chooseWitchPoisonTarget = (game, candidates) => {
                const mostMentioned = getMostMentionedTarget(messagesRef.current, candidates);
                return mostMentioned || (Math.random() < 0.4 ? candidates[Math.floor(Math.random() * candidates.length)] : null);
            };

            const advanceNightStage = (game, nextStage) => {
                game.nightStage = nextStage || getNextNightStage(game.nightStage);
                setWerewolfGame({ ...game });
                setTimeout(() => runWerewolfNight(game), 300);
            };

            const runGuardPhase = async (game) => {
                const guard = game.players.find(p => p.role === 'guard' && p.alive);
                if (!guard || game.nightActions.guardProtect) return advanceNightStage(game, 'wolf');
                const guardTargets = game.players.filter(p => p.alive && p.id !== game.lastGuarded);
                if (!guardTargets.length) return advanceNightStage(game, 'wolf');

                if (guard.isHuman) {
                    if (game.awaitingGuard) return;
                    game.awaitingGuard = true;
                    setWerewolfGame({ ...game });
                    setMessages(prev => [...prev, createSystemMsg(`üõ°Ô∏è ‰Ω†ÊòØÂÆàÂç´ÔºåËØ∑ËæìÂÖ•"ÂÆàÊä§ @Áé©ÂÆ∂Âêç"ÈÄâÊã©‰ªäÊôöÂÆàÊä§ÁöÑÁõÆÊ†áÔºà‰∏çËÉΩËøûÁª≠ÂÆàÊä§Âêå‰∏Ä‰∫∫ÔºâÔºåÊàñËæìÂÖ•"Ë∑≥Ëøá"‰∏çÂÆàÊä§„ÄÇ`)]);
                    return;
                }

                const target = chooseGuardTarget(game, guardTargets);
                if (target) {
                    game.nightActions.guardProtect = target.id;
                    game.lastGuarded = target.id;
                }
                advanceNightStage(game, 'wolf');
            };

            const runWolfPhase = async (game) => {
                if (game.nightActions.wolfKill) return advanceNightStage(game, 'witch');
                const wolves = game.players.filter(p => p.role === 'wolf' && p.alive);
                const aliveTargets = game.players.filter(p => p.alive);
                if (!wolves.length || !aliveTargets.length) {
                    game.nightActions.wolfKill = null;
                    return advanceNightStage(game, 'witch');
                }

                game.nightActions.wolfVotes = game.nightActions.wolfVotes || {};

                if (!game.nightActions.wolfDiscussed) {
                    const aiWolves = wolves.filter(w => !w.isHuman);
                    for (const wolf of aiWolves) {
                        const agent = agents.find(a => a.id === wolf.id);
                        if (!agent) continue;
                        const targetNames = aliveTargets.map(t => t.name).join('„ÄÅ');
                        const roleSummary = getRoleCountsSummary(game);
                        const replyText = await triggerAgentResponse(
                            agent,
                            smallGroupMessagesRef.current,
                            `‰Ω†ÊòØÁãº‰∫∫ÔºåÁé∞Âú®ÊòØÂ§úÊôöÔºå‰Ω†ÈúÄË¶ÅÂíåÁãºÈòüÂèãËÆ®ËÆ∫‰ªäÊôöÊùÄË∞Å„ÄÇ${roleSummary}\nÂ≠òÊ¥ªÁöÑÈùûÁãº‰∫∫Áé©ÂÆ∂ÊúâÔºö${targetNames}„ÄÇËØ∑ÁÆÄÁü≠ËÆ®ËÆ∫Âπ∂ËØ¥Âá∫‰Ω†ÊÉ≥ÊùÄÁöÑÁõÆÊ†á„ÄÇ`,
                            'small'
                        );
                        const target = getMentionedTarget(replyText, aliveTargets);
                        if (target) game.nightActions.wolfVotes[wolf.id] = target.id;
                        await new Promise(r => setTimeout(r, 1200));
                    }
                    game.nightActions.wolfDiscussed = true;
                }

                const humanWolf = wolves.find(w => w.isHuman);
                if (humanWolf && !game.nightActions.wolfVotes['player']) {
                    if (game.awaitingWolf) return;
                    game.awaitingWolf = true;
                    setWerewolfGame({ ...game });
                    setMessages(prev => [...prev, createSystemMsg(`üê∫ ‰Ω†ÊòØÁãº‰∫∫ÔºåËØ∑Âà∞Áãº‰∫∫ÂØÜËÅäÈáåËæìÂÖ•‚ÄúÂáªÊùÄ @Áé©ÂÆ∂Âêç‚ÄùÊàñ‚ÄúÊäïÁ•® @Áé©ÂÆ∂Âêç‚Äù„ÄÇ`)]);
                    setSmallGroupMessages(prev => [...prev, createSystemMsg(`üê∫ Áé©ÂÆ∂Áãº‰∫∫ËØ∑Âú®ËøôÈáåËæìÂÖ•ÂáªÊùÄÊåá‰ª§ÔºåÊàë‰ª¨Â∞ÜÊçÆÊ≠§ÁªüËÆ°ÁãºÈòüÊäïÁ•®„ÄÇ`, 'small')]);
                    return;
                }

                const aiWolves = wolves.filter(w => !w.isHuman);
                for (const wolf of aiWolves) {
                    if (game.nightActions.wolfVotes[wolf.id]) continue;
                    const agent = agents.find(a => a.id === wolf.id);
                    if (!agent) continue;
                    const decision = await decideAIVote(
                        agent,
                        'wolf',
                        smallGroupMessagesRef.current,
                        aliveTargets,
                        'small',
                        'Â§úÊôöÂáªÊùÄÊäïÁ•®'
                    );
                    if (decision) game.nightActions.wolfVotes[wolf.id] = decision.id;
                    await new Promise(r => setTimeout(r, 600));
                }

                const { voteCount, topTargets } = tallyVotes(game.nightActions.wolfVotes, aliveTargets);
                let finalTarget = topTargets[0];
                if (!finalTarget) {
                    finalTarget = getMostMentionedTarget(smallGroupMessagesRef.current, aliveTargets) || aliveTargets[0];
                }
                game.nightActions.wolfKill = finalTarget?.id || null;

                const voteLines = Object.entries(game.nightActions.wolfVotes || {}).map(([voterId, targetId]) => {
                    const voter = game.players.find(p => p.id === voterId || (voterId === 'player' && p.isHuman));
                    const target = aliveTargets.find(t => t.id === targetId);
                    return `- ${voter?.name || voterId} ‚Üí ${target?.name || targetId}`;
                }).join('\n');
                const countLines = Object.entries(voteCount).map(([targetId, count]) => {
                    const target = aliveTargets.find(t => t.id === targetId);
                    return `- ${target?.name || targetId}: ${count} Á•®`;
                }).join('\n');

                const wolfNames = wolves.map(w => w.name).join('„ÄÅ');
                setSmallGroupMessages(prev => [...prev, createSystemMsg(
                    `üó≥Ô∏è **Áãº‰∫∫ÊäïÁ•®ÊÄªÁªì**\n\nÂèÇ‰∏éÁãº‰∫∫Ôºö${wolfNames}\n\n**ÊäïÁ•®ËÆ∞ÂΩï**\n${voteLines || 'ÔºàÊó†ÊòéÁ°ÆÊäïÁ•®Ôºâ'}\n\n**Á•®Êï∞ÁªüËÆ°**\n${countLines || 'ÔºàÊó†ÁªüËÆ°Ôºâ'}\n\nÊúÄÁªàÂÜ≥ÂÆöÂáªÊùÄÔºö**${finalTarget?.name || 'Êó†‰∫∫'}**`,
                    'small'
                )]);

                advanceNightStage(game, 'witch');
            };

            const runWitchPhase = async (game) => {
                const witch = game.players.find(p => p.role === 'witch' && p.alive);
                if (!witch || (!game.witchPotion.heal && !game.witchPotion.poison)) return advanceNightStage(game, 'seer');
                if (game.nightActions.witchActed || game.nightActions.witchHeal || game.nightActions.witchPoison) {
                    return advanceNightStage(game, 'seer');
                }

                const witchIsTarget = game.nightActions.wolfKill === witch.id;
                const canSelfSave = werewolfConfig.witchSelfSave;
                const canUseHeal = game.witchPotion.heal && game.nightActions.wolfKill && (!witchIsTarget || canSelfSave);

                if (witch.isHuman) {
                    if (game.awaitingWitch) return;
                    game.awaitingWitch = true;
                    setWerewolfGame({ ...game });
                    const wolfTarget = game.players.find(p => p.id === game.nightActions.wolfKill);
                    const wolfInfo = wolfTarget ? `‰ªäÊôöÁãº‰∫∫Ë¢≠ÂáªÁöÑÊòØÔºö**${wolfTarget.name}**„ÄÇ` : '‰ªäÊôöÊó†‰∫∫Ë¢´Áãº‰∫∫Ë¢≠Âáª„ÄÇ';
                    setMessages(prev => [...prev, createSystemMsg(`üßô‚Äç‚ôÄÔ∏è ‰Ω†ÊòØÂ•≥Â∑´„ÄÇ${wolfInfo}\nÂèØËæìÂÖ•‚ÄúÊïë @Áé©ÂÆ∂Âêç‚ÄùÊàñ‚ÄúÊØí @Áé©ÂÆ∂Âêç‚ÄùÔºåÊàñËæìÂÖ•‚ÄúË∑≥Ëøá‚Äù„ÄÇ`)]);
                    return;
                }

                if (canUseHeal) {
                    const target = game.players.find(p => p.id === game.nightActions.wolfKill);
                    if (shouldWitchHeal(game, target)) {
                        game.nightActions.witchHeal = target?.id;
                        game.witchPotion.heal = false;
                        return advanceNightStage(game, 'seer');
                    }
                }

                if (game.witchPotion.poison) {
                    const poisonTargets = game.players.filter(p => p.alive && p.id !== witch.id);
                    const poisonTarget = chooseWitchPoisonTarget(game, poisonTargets);
                    if (poisonTarget) {
                        game.nightActions.witchPoison = poisonTarget.id;
                        game.witchPotion.poison = false;
                    }
                }

                advanceNightStage(game, 'seer');
            };

            const runSeerPhase = async (game) => {
                const seer = game.players.find(p => p.role === 'seer' && p.alive);
                if (!seer || game.nightActions.seerCheck) return advanceNightStage(game, 'resolve');
                const targets = game.players.filter(p => p.alive && p.id !== seer.id);
                if (!targets.length) return advanceNightStage(game, 'resolve');

                if (seer.isHuman) {
                    if (game.awaitingSeer) return;
                    game.awaitingSeer = true;
                    setWerewolfGame({ ...game });
                    setMessages(prev => [...prev, createSystemMsg(`üîÆ ‰Ω†ÊòØÈ¢ÑË®ÄÂÆ∂ÔºåËØ∑ËæìÂÖ•"Êü•È™å @Áé©ÂÆ∂Âêç"ÈÄâÊã©‰ªäÊôöÊü•È™åÁöÑÁõÆÊ†á„ÄÇ`)]);
                    return;
                }

                const checked = chooseSeerTarget(game, targets);
                const result = checked.role === 'wolf' ? 'Áãº‰∫∫' : 'Â•Ω‰∫∫';
                game.seerResult[seer.id] = { targetId: checked.id, targetName: checked.name, result, day: game.day };
                game.nightActions.seerCheck = checked.id;
                advanceNightStage(game, 'resolve');
            };

            const runWerewolfNight = async (game) => {
                if (!game || game.phase !== 'night' || isGamePaused(game)) return;
                const stage = game.nightStage || 'guard';
                if (stage === 'guard') return runGuardPhase(game);
                if (stage === 'wolf') return runWolfPhase(game);
                if (stage === 'witch') return runWitchPhase(game);
                if (stage === 'seer') return runSeerPhase(game);
                if (stage === 'resolve') return transitionToDay(game);
            };

            const transitionToDay = (game) => {
                if (isGamePaused(game)) return;

                let killed = game.nightActions.wolfKill ? game.players.find(p => p.id === game.nightActions.wolfKill) : null;

                if (game.nightActions.guardProtect && killed && killed.id === game.nightActions.guardProtect) {
                    killed = null;
                }

                if (game.nightActions.witchHeal && killed && killed.id === game.nightActions.witchHeal) {
                    killed = null;
                }

                const poisoned = game.nightActions.witchPoison ? game.players.find(p => p.id === game.nightActions.witchPoison) : null;

                let hunterKilledByWolf = null;
                if (killed && killed.role === 'hunter') {
                    hunterKilledByWolf = killed;
                    killed.alive = false;
                    setDeathLog(game, killed.id, `Á¨¨${game.day}Â§ú`, 'ÁãºÂàÄ');
                    const roleInfo = WEREWOLF_ROLES[killed.role];
                    setMessages(prev => [...prev, {
                        id: Date.now(),
                        role: 'system',
                        content: `‚òÄÔ∏è **Á¨¨ ${game.day} Â§©**\n\nÊò®ÊôöÔºå**${killed.name}** Ë¢´Áãº‰∫∫ÊùÄÂÆ≥‰∫ÜÔºÅ\n‰ªñÁöÑË∫´‰ªΩÊòØÔºö${roleInfo.emoji} ${roleInfo.name}`,
                        room: 'main',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);

                    if (killed.isHuman) {
                        game.pendingHunterShot = 'player';
                        game.phase = 'day';
                        game.nightActions = {};
                        game.awaitingGuard = false;
                        game.awaitingSeer = false;
                        game.awaitingWitch = false;
                        game.awaitingWolf = false;
                        game.nightStage = 'guard';
                        setMessages(prev => [...prev, {
                            id: Date.now() + 1,
                            role: 'system',
                            content: `üèπ ‰Ω†ÊòØÁåé‰∫∫ÔºåËØ∑ËæìÂÖ•"ÂºÄÊû™ @Áé©ÂÆ∂Âêç"ÈÄâÊã©Â∏¶Ëµ∞ÁõÆÊ†áÔºåÊàñËæìÂÖ•"‰∏çÂºÄÊû™"ÊîæÂºÉ„ÄÇ`,
                            room: 'main',
                            time: formatTime(Date.now()),
                            isSystem: true
                        }]);
                        setWerewolfGame({ ...game });
                        return;
                    } else {
                        const hunterTargets = game.players.filter(p => p.alive && p.id !== killed.id);
                        const target = hunterTargets[Math.floor(Math.random() * hunterTargets.length)];
                        if (target) {
                            target.alive = false;
                            setDeathLog(game, target.id, `Á¨¨${game.day}Â§©`, 'Êû™ÊùÄ');
                            const targetRole = WEREWOLF_ROLES[target.role];
                            setMessages(prev => [...prev, {
                                id: Date.now() + 2,
                                role: 'system',
                                content: `üèπ **${killed.name}** ÂèëÂä®Áåé‰∫∫ÊäÄËÉΩÔºåÂ∏¶Ëµ∞‰∫Ü **${target.name}**ÔºÅ\n${target.name} ÁöÑË∫´‰ªΩÊòØÔºö${targetRole.emoji} ${targetRole.name}`,
                                room: 'main',
                                time: formatTime(Date.now()),
                                isSystem: true
                            }]);
                        }
                    }
                    killed = null;
                } else if (killed) {
                    killed.alive = false;
                    setDeathLog(game, killed.id, `Á¨¨${game.day}Â§ú`, 'ÁãºÂàÄ');
                    const roleInfo = WEREWOLF_ROLES[killed.role];
                    const dayMsg = `‚òÄÔ∏è **Á¨¨ ${game.day} Â§©**\n\nÊò®ÊôöÔºå**${killed.name}** Ë¢´Áãº‰∫∫ÊùÄÂÆ≥‰∫ÜÔºÅ\n‰ªñÁöÑË∫´‰ªΩÊòØÔºö${roleInfo.emoji} ${roleInfo.name}\n\nËØ∑ÊåâÈ°∫Â∫èÂèëË®ÄÔºåËÆ®ËÆ∫Ë∞ÅÊòØÁãº‰∫∫„ÄÇ`;
                    setMessages(prev => [...prev, createSystemMsg(dayMsg)]);
                } else {
                    setMessages(prev => [...prev, createSystemMsg(`‚òÄÔ∏è **Á¨¨ ${game.day} Â§©**\n\nÊò®ÊôöÊòØÂπ≥ÂÆâÂ§úÔºåÊó†‰∫∫Ê≠ª‰∫°„ÄÇ\n\nËØ∑ÊåâÈ°∫Â∫èÂèëË®ÄÔºåËÆ®ËÆ∫Ë∞ÅÊòØÁãº‰∫∫„ÄÇ`)]);
                }

                if (poisoned) {
                    poisoned.alive = false;
                    setDeathLog(game, poisoned.id, `Á¨¨${game.day}Â§ú`, 'ÊØíÊ≠ª');
                    const roleInfo = WEREWOLF_ROLES[poisoned.role];
                    setMessages(prev => [...prev, createSystemMsg(`üß™ **${poisoned.name}** Ë¢´Â•≥Â∑´ÊØíÊ≠ª‰∫ÜÔºÅ\nË∫´‰ªΩÊè≠ÊôìÔºö${roleInfo.emoji} ${roleInfo.name}`)]);
                }

                game.phase = 'day';
                game.currentSpeaker = 0;
                game.nightActions = {};
                game.awaitingWitch = false;
                game.awaitingGuard = false;
                game.awaitingSeer = false;
                game.awaitingWolf = false;
                game.awaitingDaySpeech = null;
                game.nightStage = 'guard';

                const startSeatId = killed?.id || poisoned?.id || game.players[0]?.id;
                const startIndex = Math.max(0, game.players.findIndex(p => p.id === startSeatId));
                game.dayStartIndex = startIndex;
                const order = [];
                for (let i = 0; i < game.players.length; i++) {
                    const idx = (startIndex + i) % game.players.length;
                    const player = game.players[idx];
                    if (player?.alive) order.push(player.id);
                }
                game.daySpeechOrder = order;
                game.daySpeechPos = 0;

                setWerewolfGame({ ...game });

                if (checkWerewolfWin(game)) return;

                setTimeout(() => runWerewolfDaySpeech(game), 2000);
            };

            const runWerewolfDaySpeech = async (game) => {
                if (!game || game.phase !== 'day' || isGamePaused(game)) return;

                const alivePlayers = game.players.filter(p => p.alive);
                if (!alivePlayers.length) return;

                const orderIds = (game.daySpeechOrder && game.daySpeechOrder.length)
                    ? game.daySpeechOrder
                    : alivePlayers.map(p => p.id);

                while (game.daySpeechPos < orderIds.length) {
                    if (isGamePaused(game)) return;
                    const player = game.players.find(p => p.id === orderIds[game.daySpeechPos]);
                    if (!player || !player.alive) {
                        game.daySpeechPos += 1;
                        continue;
                    }

                    if (player.isHuman) {
                        if (game.awaitingDaySpeech) return;
                        game.awaitingDaySpeech = player.id;
                        setWerewolfGame({ ...game });
                        setMessages(prev => [...prev, createSystemMsg(`üì¢ ËΩÆÂà∞ **${player.name}** (‰Ω†) ÂèëË®ÄÔºåËØ∑Âú®‰∏ãÊñπËæìÂÖ•‰Ω†ÁöÑÂèëË®Ä„ÄÇ`)]);
                        return;
                    }

                    const agent = agents.find(a => a.id === player.id);
                    if (agent) {
                        const roleInfo = WEREWOLF_ROLES[player.role];
                        const aliveNames = alivePlayers.filter(p => p.id !== player.id).map(p => p.name).join('„ÄÅ');
                        let context = `${werewolfRolePrompts[player.role] || ''}\n‰Ω†Ê≠£Âú®Áé©Áãº‰∫∫ÊùÄÊ∏∏ÊàèÔºå‰Ω†ÁöÑË∫´‰ªΩÊòØ${roleInfo.name}„ÄÇ${getRoleCountsSummary(game)}`;
                        if (player.role === 'seer' && game.seerResult?.[player.id]) {
                            const res = game.seerResult[player.id];
                            const target = game.players.find(p => p.id === res.targetId);
                            context += `\n‰Ω†Êò®ÊôöÊü•È™å‰∫Ü${target?.name || 'Êüê‰∫∫'}ÔºåÁªìÊûúÊòØ${res.result}„ÄÇ`;
                        }
                        if (player.role === 'wolf') context += `‰Ω†ÈúÄË¶ÅÈöêËóèË∫´‰ªΩÔºåÂÅáË£ÖÊòØÂ•Ω‰∫∫ÔºåÂπ∂Â∞ùËØïËØØÂØºÂÖ∂‰ªñ‰∫∫„ÄÇ`;
                        else context += `‰Ω†ÈúÄË¶ÅÈÄöËøáÈÄªËæëÂàÜÊûêÊâæÂá∫Áãº‰∫∫„ÄÇ`;
                        context += `Â≠òÊ¥ªÁé©ÂÆ∂Ôºö${aliveNames}„ÄÇËØ∑ÂèëË°®‰Ω†ÁöÑÁúãÊ≥ïÔºåÁÆÄÁü≠ÊúâÈÄªËæëÔºåÂèØ‰ª•ÊåáÂá∫‰Ω†ÊÄÄÁñëÁöÑ‰∫∫„ÄÇ`;

                        await triggerAgentResponse(agent, messagesRef.current, context, 'main');
                        game.daySpeechPos += 1;
                        setWerewolfGame({ ...game });
                        await new Promise(r => setTimeout(r, 1800));
                        continue;
                    }

                    game.daySpeechPos += 1;
                }

                setTimeout(() => startWerewolfVote(game), 1500);
            };

            const startWerewolfVote = (game) => {
                if (isGamePaused(game)) return;
                game.phase = 'vote';
                game.awaitingDaySpeech = null;
                const alivePlayers = game.players.filter(p => p.alive && p.canVote);

                let voteMsg = `üó≥Ô∏è **ÊäïÁ•®ÁéØËäÇ**\n\nËØ∑ÊäïÁ•®ÈÄâÂá∫‰Ω†ËÆ§‰∏∫ÊòØÁãº‰∫∫ÁöÑÁé©ÂÆ∂ÔºàÂèØÂºÉÁ•®ÔºâÔºö\n\n`;
                alivePlayers.forEach((p, i) => {
                    voteMsg += `${i + 1}. ${p.name}\n`;
                });
                voteMsg += `0. ÂºÉÁ•®\n`;

                if (game.players.find(p => p.isHuman && p.alive && p.canVote)) {
                    voteMsg += `\nËØ∑ËæìÂÖ•‰Ω†Ë¶ÅÊäïÁ•®ÁöÑÁé©ÂÆ∂ÂêçÂ≠óÔºàÂ¶ÇÔºö@ÊüêÊüêÊüêÔºâÔºåÊàñËæìÂÖ•‚ÄúÂºÉÁ•®‚Äù„ÄÇ`;
                }

                setMessages(prev => [...prev, createSystemMsg(voteMsg)]);

                setWerewolfGame({ ...game });

                setTimeout(() => runWerewolfAIVote(game), 2000);
            };

            const runWerewolfAIVote = async (game) => {
                if (isGamePaused(game)) return;
                const alivePlayers = game.players.filter(p => p.alive);
                const votes = {};

                for (const player of alivePlayers) {
                    if (!player.isHuman && player.canVote) {
                        const targets = alivePlayers.filter(p => p.id !== player.id);
                        const agent = agents.find(a => a.id === player.id);
                        if (!agent) continue;

                        const decision = await decideAIVote(
                            agent,
                            player.role,
                            messagesRef.current,
                            targets,
                            'main',
                            'ÁôΩÂ§©ÊäïÁ•®'
                        );

                        if (decision) {
                            votes[player.id] = decision.id;
                            setMessages(prev => [...prev, createAssistantMsg(`ÊàëÊäï **${decision.name}**`, player)]);
                            await new Promise(r => setTimeout(r, 800));
                        } else {
                            votes[player.id] = 'abstain';
                            setMessages(prev => [...prev, createAssistantMsg(`ÊàëÂºÉÁ•®`, player)]);
                            await new Promise(r => setTimeout(r, 500));
                        }
                    }
                }

                const existingPlayerVote = game.votes?.player;
                game.votes = { ...votes };
                if (existingPlayerVote) game.votes.player = existingPlayerVote;
                setWerewolfGame({ ...game });

                const humanPlayer = game.players.find(p => p.isHuman && p.alive && p.canVote);
                if (!humanPlayer) {
                    setTimeout(() => resolveWerewolfVote(game), 1500);
                } else if (game.votes?.player && areAllVotesIn(game)) {
                    setTimeout(() => resolveWerewolfVote(game), 1500);
                }
            };

            const resolveWerewolfVote = async (game) => {
                if (isGamePaused(game)) return;
                const { voteCount, maxVotes, topTargets } = tallyVotes(game.votes || {}, game.players);

                if (Object.keys(game.votes || {}).length > 0) {
                    const voteLines = Object.entries(game.votes).map(([voterId, targetId]) => {
                        const voter = game.players.find(p => p.id === voterId || (voterId === 'player' && p.isHuman));
                        if (targetId === 'abstain') return `- ${voter?.name || voterId} ‚Üí ÂºÉÁ•®`;
                        const target = game.players.find(p => p.id === targetId);
                        return `- ${voter?.name || voterId} ‚Üí ${target?.name || targetId}`;
                    }).join('\n');
                    const countLines = Object.entries(voteCount).map(([targetId, count]) => {
                        const target = game.players.find(p => p.id === targetId);
                        return `- ${target?.name || targetId}: ${count} Á•®`;
                    }).join('\n');

                    setMessages(prev => [...prev, createSystemMsg(`üßæ **ÊäïÁ•®ÊÄªÁªì**\n\n**ÊäïÁ•®ËÆ∞ÂΩï**\n${voteLines}\n\n**Á•®Êï∞ÁªüËÆ°**\n${countLines}`)]);
                }

                const maxVotePlayers = topTargets;

                if (!maxVotePlayers.length) {
                    setMessages(prev => [...prev, createSystemMsg(`üïäÔ∏è **Êó†‰∫∫ÊäïÁ•®**ÔºåÊú¨ËΩÆÊó†‰∫∫Âá∫Â±Ä„ÄÇ`)]);
                    setWerewolfGame({ ...game });
                    game.day++;
                    game.phase = 'night';
                    game.votes = {};
                    game.nightStage = 'guard';
                    setTimeout(() => {
                        setMessages(prev => [...prev, createSystemMsg(`üåô **Á¨¨ ${game.day} Â§úÈôç‰∏¥ÔºåËØ∑Èó≠Áúº...**`)]);
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 2000);
                    }, 2000);
                    return;
                }

                if (maxVotePlayers.length > 1) {
                    const tiedNames = maxVotePlayers.map(p => p.name).join('„ÄÅ');
                    setMessages(prev => [...prev, createSystemMsg(`‚öñÔ∏è **Âπ≥Á•®ÔºÅ** ${tiedNames} ÂêÑÂæó ${maxVotes} Á•®ÔºåÊú¨ËΩÆÊó†‰∫∫Âá∫Â±Ä„ÄÇ`)]);

                    setWerewolfGame({ ...game });

                    game.day++;
                    game.phase = 'night';
                    game.votes = {};
                    game.nightStage = 'guard';

                    setTimeout(() => {
                        setMessages(prev => [...prev, {
                            id: Date.now(),
                            role: 'system',
                            content: `üåô **Á¨¨ ${game.day} Â§úÈôç‰∏¥ÔºåËØ∑Èó≠Áúº...**`,
                            room: 'main',
                            time: formatTime(Date.now()),
                            isSystem: true
                        }]);
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 2000);
                    }, 2000);
                    return;
                }

                const eliminated = maxVotePlayers[0];

                if (eliminated) {
                    const roleInfo = WEREWOLF_ROLES[eliminated.role];

                    if (eliminated.role === 'idiot' && !game.idiotRevealed) {
                        game.idiotRevealed = true;
                        eliminated.canVote = false;
                        setMessages(prev => [...prev, {
                            id: Date.now(),
                            role: 'system',
                            content: `ü§™ **${eliminated.name}** ÁøªÂá∫Ë∫´‰ªΩÁâåÔºö${roleInfo.emoji} ${roleInfo.name}ÔºÅ\n\nÁôΩÁó¥ÂÖçÊ≠ªÔºå‰ΩÜÂ§±ÂéªÊäïÁ•®ÊùÉ„ÄÇÊ∏∏ÊàèÁªßÁª≠ÔºÅ`,
                            room: 'main',
                            time: formatTime(Date.now()),
                            isSystem: true
                        }]);
                        setWerewolfGame({ ...game });
                        setTimeout(() => {
                            game.day++;
                            game.phase = 'night';
                            game.votes = {};
                            game.nightStage = 'guard';
                            game.awaitingGuard = false;
                            game.awaitingSeer = false;
                            game.awaitingWitch = false;
                            game.awaitingWolf = false;
                            setMessages(prev => [...prev, {
                                id: Date.now(),
                                role: 'system',
                                content: `üåô **Á¨¨ ${game.day} Â§úÈôç‰∏¥ÔºåËØ∑Èó≠Áúº...**`,
                                room: 'main',
                                time: formatTime(Date.now()),
                                isSystem: true
                            }]);
                            setWerewolfGame({ ...game });
                            setTimeout(() => runWerewolfNight(game), 2000);
                        }, 2000);
                        return;
                    }

                    eliminated.alive = false;
                    setDeathLog(game, eliminated.id, `Á¨¨${game.day}Â§©`, 'Á•®Ê≠ª');

                    setMessages(prev => [...prev, {
                        id: Date.now(),
                        role: 'system',
                        content: `‚ö∞Ô∏è **${eliminated.name}** Ë¢´ÊäïÁ•®Âá∫Â±ÄÔºÅ\nË∫´‰ªΩÊè≠ÊôìÔºö${roleInfo.emoji} ${roleInfo.name}`,
                        room: 'main',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);

                    enqueueLastWords(game, eliminated.id, 'Á•®Ê≠ª');
                    game.pendingPostLastWords = {
                        type: 'afterVote',
                        hunterId: eliminated.role === 'hunter' ? eliminated.id : null
                    };

                    const waiting = await processLastWordsQueue(game);
                    if (waiting) {
                        setWerewolfGame({ ...game });
                        return;
                    }
                    await continueAfterLastWords(game);
                    return;
                }

                setWerewolfGame({ ...game });

                if (checkWerewolfWin(game)) return;

                proceedToNextNight(game);
            };

            const checkWerewolfWin = (game) => {
                const aliveWolves = game.players.filter(p => p.alive && p.role === 'wolf').length;
                const aliveVillagers = game.players.filter(p => p.alive && p.role !== 'wolf').length;

                const buildRecap = (title) => {
                    const lines = game.players.map(p => {
                        const roleInfo = WEREWOLF_ROLES[p.role];
                        const deathInfo = game.deathLog?.[p.id];
                        const status = p.alive ? 'ÔºàÂ≠òÊ¥ªÔºâ' : (deathInfo ? `Ôºà${deathInfo.when}¬∑${deathInfo.cause}Ôºâ` : 'ÔºàÊ≠ª‰∫°Ôºâ');
                        return `- ${p.name}: ${roleInfo?.emoji} ${roleInfo?.name} ${status}`;
                    }).join('\n');
                    return `${title}\n\n**Ë∫´‰ªΩÂ§çÁõò**\n${lines}`;
                };

                if (aliveWolves === 0) {
                    setMessages(prev => [...prev, {
                        id: Date.now(),
                        role: 'system',
                        content: `üéâ **Ê∏∏ÊàèÁªìÊùüÔºÅÂ•Ω‰∫∫ÈòµËê•ËÉúÂà©ÔºÅ** üéâ\n\nÊâÄÊúâÁãº‰∫∫Â∑≤Ë¢´Ê∂àÁÅ≠ÔºÅ`,
                        room: 'main',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);
                    setMessages(prev => [...prev, {
                        id: Date.now() + 1,
                        role: 'system',
                        content: buildRecap('üìå **Â§çÁõòÊÄªÁªì**'),
                        room: 'main',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);
                    setWerewolfGame(null);
                    return true;
                }

                if (aliveWolves >= aliveVillagers) {
                    setMessages(prev => [...prev, {
                        id: Date.now(),
                        role: 'system',
                        content: `üê∫ **Ê∏∏ÊàèÁªìÊùüÔºÅÁãº‰∫∫ÈòµËê•ËÉúÂà©ÔºÅ** üê∫\n\nÁãº‰∫∫Êï∞ÈáèÂ∑≤ËææÂà∞ÊàñË∂ÖËøáÂ•Ω‰∫∫Êï∞ÈáèÔºÅ`,
                        room: 'main',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);
                    setMessages(prev => [...prev, {
                        id: Date.now() + 1,
                        role: 'system',
                        content: buildRecap('üìå **Â§çÁõòÊÄªÁªì**'),
                        room: 'main',
                        time: formatTime(Date.now()),
                        isSystem: true
                    }]);
                    setWerewolfGame(null);
                    return true;
                }

                return false;
            };

            const handleWerewolfPlayerAction = (input, inputRoom = 'main') => {
                if (!werewolfGame) return false;

                const game = werewolfGame;

                if (isGamePaused(game)) return true;

                if (game.phase === 'night' && game.awaitingGuard) {
                    const guardTargets = game.players.filter(p => p.alive && p.id !== game.lastGuarded);
                    if (input.includes('Ë∑≥Ëøá')) {
                        game.awaitingGuard = false;
                        game.nightActions.guardProtect = null;
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 500);
                        return true;
                    }
                    const target = guardTargets.find(p => input.includes(`@${p.name}`) || input.includes(p.name));
                    if (target && input.includes('ÂÆàÊä§')) {
                        game.nightActions.guardProtect = target.id;
                        game.lastGuarded = target.id;
                        game.awaitingGuard = false;
                        setMessages(prev => [...prev, createUserMsg(`ÊàëÂÆàÊä§‰∫Ü ${target.name}`, 'main', { isAction: true, actionType: 'action' })]);
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 500);
                        return true;
                    }
                }

                if (game.phase === 'night' && game.awaitingWolf) {
                    const aliveTargets = game.players.filter(p => p.alive && p.role !== 'wolf');
                    const target = getMentionedTarget(input, aliveTargets);
                    if (target && (input.includes('ÂáªÊùÄ') || input.includes('ÊäïÁ•®') || input.includes('ÊùÄ') || input.includes('ÂàÄ'))) {
                        game.nightActions.wolfVotes = game.nightActions.wolfVotes || {};
                        game.nightActions.wolfVotes['player'] = target.id;
                        game.awaitingWolf = false;
                        const wolfMsg = createUserMsg(`ÊàëÈÄâÊã©ÂáªÊùÄ ${target.name}`, inputRoom, { isAction: true, actionType: 'vote' });
                        if (inputRoom === 'small') {
                            setSmallGroupMessages(prev => [...prev, wolfMsg]);
                        } else {
                            setMessages(prev => [...prev, wolfMsg]);
                        }
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 500);
                        return true;
                    }
                }

                if (game.phase === 'night' && game.awaitingSeer) {
                    const targets = game.players.filter(p => p.alive && !p.isHuman);
                    const target = targets.find(p => input.includes(`@${p.name}`) || input.includes(p.name));
                    if (target && input.includes('Êü•È™å')) {
                        const result = target.role === 'wolf' ? 'Áãº‰∫∫' : 'Â•Ω‰∫∫';
                        const seer = game.players.find(p => p.role === 'seer' && p.isHuman);
                        game.seerResult[seer.id] = { targetId: target.id, targetName: target.name, result, day: game.day };
                        game.nightActions.seerCheck = target.id;
                        game.awaitingSeer = false;
                        setMessages(prev => [...prev, createSystemMsg(`üîÆ ‰Ω†Êü•È™å‰∫Ü **${target.name}**ÔºåÁªìÊûúÊòØÔºö**${result}**„ÄÇ`)]);
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 500);
                        return true;
                    }
                }

                if (game.phase === 'night' && game.awaitingWitch) {
                    const alivePlayers = game.players.filter(p => p.alive);
                    const witch = game.players.find(p => p.role === 'witch' && p.isHuman);
                    const target = alivePlayers.find(p => input.includes(`@${p.name}`) || input.includes(p.name));
                    if (input.includes('Ë∑≥Ëøá')) {
                        game.awaitingWitch = false;
                        game.nightActions.witchActed = true;
                        game.nightStage = 'seer';
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfNight(game), 500);
                        return true;
                    }
                    if (target) {
                        if (input.includes('Êïë') && game.witchPotion.heal) {
                            const isSelfSave = target.id === witch?.id;
                            if (isSelfSave && !werewolfConfig.witchSelfSave) {
                                setMessages(prev => [...prev, createSystemMsg(`‚ö†Ô∏è Êú¨Â±ÄËßÑÂàôÁ¶ÅÊ≠¢Â•≥Â∑´Ëá™ÊïëÔºåËØ∑ÈÄâÊã©ÂÖ∂‰ªñÁõÆÊ†áÊàñËæìÂÖ•"Ë∑≥Ëøá"„ÄÇ`)]);
                                return true;
                            }
                            game.nightActions.witchHeal = target.id;
                            game.nightActions.witchActed = true;
                            game.witchPotion.heal = false;
                            game.awaitingWitch = false;
                            game.nightStage = 'seer';
                            setMessages(prev => [...prev, createUserMsg(`Êàë‰ΩøÁî®Ëß£ËçØÊïë‰∫Ü ${target.name}`, 'main', { isAction: true, actionType: 'action' })]);
                            setWerewolfGame({ ...game });
                            setTimeout(() => runWerewolfNight(game), 500);
                            return true;
                        }
                        if (input.includes('ÊØí') && game.witchPotion.poison) {
                            game.nightActions.witchPoison = target.id;
                            game.nightActions.witchActed = true;
                            game.witchPotion.poison = false;
                            game.awaitingWitch = false;
                            game.nightStage = 'seer';
                            setMessages(prev => [...prev, createUserMsg(`Êàë‰ΩøÁî®ÊØíËçØÊØí‰∫Ü ${target.name}`, 'main', { isAction: true, actionType: 'action' })]);
                            setWerewolfGame({ ...game });
                            setTimeout(() => runWerewolfNight(game), 500);
                            return true;
                        }
                    }
                }

                if (game.pendingHunterShot === 'player') {
                    if (input.includes('‰∏çÂºÄÊû™')) {
                        game.pendingHunterShot = null;
                        setMessages(prev => [...prev, createUserMsg(`ÊàëÈÄâÊã©‰∏çÂºÄÊû™`, 'main', { isAction: true, actionType: 'action' })]);
                        setWerewolfGame({ ...game });
                        if (checkWerewolfWin(game)) return true;
                        proceedToNextNight(game, 1000);
                        return true;
                    }
                    const alivePlayers = game.players.filter(p => p.alive);
                    const target = alivePlayers.find(p => input.includes(`@${p.name}`) || input.includes(p.name));
                    if (target && input.includes('ÂºÄÊû™')) {
                        target.alive = false;
                        game.pendingHunterShot = null;
                        setDeathLog(game, target.id, `Á¨¨${game.day}Â§©`, 'Êû™ÊùÄ');
                        const targetRole = WEREWOLF_ROLES[target.role];
                        setMessages(prev => [...prev, createUserMsg(`ÊàëÂºÄÊû™Â∏¶Ëµ∞‰∫Ü ${target.name}`, 'main', { isAction: true, actionType: 'action' })]);
                        setMessages(prev => [...prev, createSystemMsg(`${target.name} ÁöÑË∫´‰ªΩÊòØÔºö${targetRole.emoji} ${targetRole.name}`)]);
                        setWerewolfGame({ ...game });
                        if (checkWerewolfWin(game)) return true;
                        enqueueLastWords(game, target.id, 'Êû™ÊùÄ');
                        game.pendingPostLastWords = { type: 'afterHunterShot' };
                        processLastWordsQueue(game).then((waiting) => {
                            if (waiting) return;
                            continueAfterLastWords(game);
                        });
                        return true;
                    }
                }

                if (game.awaitingLastWords) {
                    const target = game.players.find(p => p.id === game.awaitingLastWords.playerId);
                    if (target?.isHuman) {
                        setMessages(prev => [...prev, createUserMsg(input, 'main', { isAction: true, actionType: 'action' })]);
                        game.awaitingLastWords = null;
                        setWerewolfGame({ ...game });
                        processLastWordsQueue(game).then((waiting) => {
                            if (waiting) return;
                            continueAfterLastWords(game);
                        });
                        return true;
                    }
                }

                if (game.phase === 'vote') {
                    const alivePlayers = game.players.filter(p => p.alive);
                    if (input.includes('ÂºÉÁ•®')) {
                        game.votes = game.votes || {};
                        game.votes['player'] = 'abstain';
                        setMessages(prev => [...prev, createUserMsg(`ÊàëÂºÉÁ•®`, 'main', { isAction: true, actionType: 'vote' })]);
                        setWerewolfGame({ ...game });
                        if (areAllVotesIn(game)) {
                            setTimeout(() => resolveWerewolfVote(game), 1500);
                        } else {
                            setMessages(prev => [...prev, createSystemMsg(`üïí Â∑≤ËÆ∞ÂΩï‰Ω†ÁöÑÂºÉÁ•®ÔºåÁ≠âÂæÖÂÖ∂‰ªñÁé©ÂÆ∂ÂÆåÊàêÊäïÁ•®„ÄÇ`)]);
                        }
                        return true;
                    }
                    const mentioned = alivePlayers.find(p => input.includes(`@${p.name}`) || input.includes(p.name));

                    if (mentioned) {
                        game.votes = game.votes || {};
                        game.votes['player'] = mentioned.id;

                        setMessages(prev => [...prev, createUserMsg(`ÊàëÊäï **${mentioned.name}**`, 'main', { isAction: true, actionType: 'vote' })]);

                        setWerewolfGame({ ...game });
                        if (areAllVotesIn(game)) {
                            setTimeout(() => resolveWerewolfVote(game), 1500);
                        } else {
                            setMessages(prev => [...prev, createSystemMsg(`üïí Â∑≤ËÆ∞ÂΩï‰Ω†ÁöÑÊäïÁ•®ÔºåÁ≠âÂæÖÂÖ∂‰ªñÁé©ÂÆ∂ÂÆåÊàêÊäïÁ•®„ÄÇ`)]);
                        }
                        return true;
                    }
                }

                if (game.phase === 'day' && game.awaitingDaySpeech) {
                    const current = game.players.find(p => p.id === game.awaitingDaySpeech);
                    if (current?.isHuman) {
                        setMessages(prev => [...prev, createUserMsg(input)]);
                        game.awaitingDaySpeech = null;
                        game.daySpeechPos += 1;
                        setWerewolfGame({ ...game });
                        setTimeout(() => runWerewolfDaySpeech(game), 500);
                        return true;
                    }
                }

                return false;
            };

            const toggleWerewolfPause = () => {
                if (!werewolfGame) return;
                const next = { ...werewolfGame, paused: !werewolfGame.paused };
                setWerewolfGame(next);

                if (!next.paused) {
                    if (next.phase === 'night') setTimeout(() => runWerewolfNight(next), 500);
                    if (next.phase === 'day') setTimeout(() => runWerewolfDaySpeech(next), 500);
                    if (next.phase === 'vote') setTimeout(() => resolveWerewolfVote(next), 500);
                }
            };

            const setDeathLog = (game, playerId, whenLabel, causeLabel) => {
                if (!playerId) return;
                game.deathLog = game.deathLog || {};
                game.deathLog[playerId] = { when: whenLabel, cause: causeLabel };
            };

            const proceedToNextNight = (game, delay = 2000) => {
                game.day++;
                game.phase = 'night';
                game.votes = {};
                game.nightStage = 'guard';
                game.awaitingGuard = false;
                game.awaitingSeer = false;
                game.awaitingWitch = false;
                game.awaitingWolf = false;
                game.awaitingDaySpeech = null;
                game.daySpeechOrder = [];
                game.daySpeechPos = 0;

                setTimeout(() => {
                    setMessages(prev => [...prev, createSystemMsg(`üåô **Á¨¨ ${game.day} Â§úÈôç‰∏¥ÔºåËØ∑Èó≠Áúº...**`)]);
                    setWerewolfGame({ ...game });
                    setTimeout(() => runWerewolfNight(game), 2000);
                }, delay);
            };

            const enqueueLastWords = (game, playerId, reasonLabel) => {
                if (!playerId) return;
                game.lastWordsQueue = game.lastWordsQueue || [];
                game.lastWordsQueue.push({ playerId, reason: reasonLabel });
            };

            const processLastWordsQueue = async (game) => {
                if (game.awaitingLastWords) return true;
                while (game.lastWordsQueue?.length) {
                    const next = game.lastWordsQueue.shift();
                    const player = game.players.find(p => p.id === next.playerId);
                    if (!player) continue;
                    if (player.isHuman) {
                        game.awaitingLastWords = next;
                        setWerewolfGame({ ...game });
                        setMessages(prev => [...prev, createSystemMsg(`üìù ‰Ω†Ë¢´${next.reason}ÔºåËØ∑ÂèëË°®ÈÅóË®Ä„ÄÇ`)]);
                        return true;
                    }
                    const agent = agents.find(a => a.id === player.id);
                    if (agent) {
                        await triggerAgentResponse(agent, messagesRef.current, `‰Ω†Ë¢´${next.reason}ÔºåËØ∑ÂèëË°®ÈÅóË®Ä„ÄÇ`, 'main');
                    } else {
                        setMessages(prev => [...prev, createSystemMsg(`üìù **${player.name}** Ë¢´${next.reason}ÔºåÊú™ËÉΩÂèëË®Ä„ÄÇ`)]);
                    }
                }
                return false;
            };

            const continueAfterLastWords = async (game) => {
                const pending = game.pendingPostLastWords;
                game.pendingPostLastWords = null;
                if (!pending) return;

                if (pending.type === 'afterVote') {
                    if (pending.hunterId) {
                        const hunter = game.players.find(p => p.id === pending.hunterId);
                        if (hunter?.isHuman) {
                            game.pendingHunterShot = 'player';
                            setWerewolfGame({ ...game });
                            setMessages(prev => [...prev, createSystemMsg(`üèπ ‰Ω†ÊòØÁåé‰∫∫ÔºåËØ∑ËæìÂÖ•‚ÄúÂºÄÊû™ @Áé©ÂÆ∂Âêç‚ÄùÈÄâÊã©Â∏¶Ëµ∞ÁõÆÊ†á„ÄÇ`)]);
                            return;
                        }
                        if (hunter) {
                            const targets = game.players.filter(p => p.alive && p.id !== hunter.id);
                            const target = targets[Math.floor(Math.random() * targets.length)];
                            if (target) {
                                target.alive = false;
                                setDeathLog(game, target.id, `Á¨¨${game.day}Â§©`, 'Êû™ÊùÄ');
                                setMessages(prev => [...prev, createSystemMsg(`üèπ **${hunter.name}** ÂºÄÊû™Â∏¶Ëµ∞‰∫Ü **${target.name}**ÔºÅ`)]);
                                enqueueLastWords(game, target.id, 'Êû™ÊùÄ');
                            }
                        }
                        const waiting = await processLastWordsQueue(game);
                        if (waiting) return;
                        return proceedToNextNight(game);
                    }
                    return proceedToNextNight(game);
                }

                if (pending.type === 'afterHunterShot') {
                    return proceedToNextNight(game);
                }
            };

            // Áãº‰∫∫ÊùÄËÆæÁΩÆÈù¢Êùø
            const WerewolfSetupModal = ({ open, onClose, config, setConfig, onStart, agents, darkMode }) => {
                if (!open) return null;

                const enabledAgents = agents.filter(a => a.enabled);
                const totalPlayers = config.playerJoin ? enabledAgents.length + 1 : enabledAgents.length;
                const availableRoles = ['seer', 'witch', 'hunter', 'guard', 'idiot'];

                const toggleRole = (role) => {
                    setConfig(prev => ({
                        ...prev,
                        roles: prev.roles.includes(role)
                            ? prev.roles.filter(r => r !== role)
                            : [...prev.roles, role]
                    }));
                };

                return (
                    <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 fade-enter">
                        <div className={cn("w-full max-w-md rounded-xl shadow-2xl p-6", darkMode ? "bg-zinc-900 border border-zinc-800 text-zinc-100" : "bg-white text-zinc-900")}>
                            <h2 className="text-lg font-bold mb-4 flex items-center gap-2">
                                <Icons.Wolf className="w-6 h-6 text-red-500"/> Áãº‰∫∫ÊùÄÊ∏∏ÊàèËÆæÁΩÆ
                            </h2>

                            <div className="space-y-4">
                                <div className="p-3 rounded-lg bg-zinc-100 dark:bg-zinc-800 text-sm">
                                    <p>ÂΩìÂâçÂêØÁî®ÊºîÂëòÔºö<strong>{enabledAgents.length}</strong> ‰∫∫</p>
                                    <p>ÊÄªÁé©ÂÆ∂Êï∞Ôºö<strong>{totalPlayers}</strong> ‰∫∫</p>
                                </div>

                                <div>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={config.playerJoin}
                                            onChange={e => setConfig({...config, playerJoin: e.target.checked})}
                                            className="w-4 h-4"
                                        />
                                        <span className="text-sm">Êàë‰Ωú‰∏∫Áé©ÂÆ∂ÂèÇ‰∏éÊ∏∏Êàè</span>
                                    </label>
                                    {config.playerJoin && (
                                        <input
                                            value={config.playerName}
                                            onChange={e => setConfig({...config, playerName: e.target.value})}
                                            placeholder="‰Ω†ÁöÑÂêçÂ≠ó"
                                            className={cn("mt-2 w-full px-3 py-2 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}
                                        />
                                    )}
                                </div>

                                <div>
                                    <label className="block text-xs font-medium text-zinc-500 mb-1">Áãº‰∫∫Êï∞Èáè</label>
                                    <input
                                        type="number"
                                        min="1"
                                        max={Math.max(1, Math.floor(totalPlayers / 3))}
                                        value={config.wolfCount}
                                        onChange={e => setConfig({...config, wolfCount: parseInt(e.target.value) || 1})}
                                        className={cn("w-full px-3 py-2 rounded border text-sm", darkMode ? "bg-zinc-950 border-zinc-700" : "bg-white border-zinc-200")}
                                    />
                                    <p className="text-[10px] text-zinc-500 mt-1">Âª∫ËÆÆÔºö{totalPlayers}‰∫∫Â±ÄÊé®Ëçê {Math.max(1, Math.floor(totalPlayers / 4))} Âè™Áãº</p>
                                </div>

                                <div>
                                    <label className="block text-xs font-medium text-zinc-500 mb-2">ÈÄâÊã©Á•ûËÅå</label>
                                    <div className="flex flex-wrap gap-2">
                                        {availableRoles.map(role => {
                                            const info = WEREWOLF_ROLES[role];
                                            const selected = config.roles.includes(role);
                                            return (
                                                <button
                                                    key={role}
                                                    onClick={() => toggleRole(role)}
                                                    className={cn(
                                                        "px-3 py-1.5 rounded-full text-xs font-medium border transition-all",
                                                        selected
                                                            ? "bg-purple-600 text-white border-purple-600"
                                                            : "border-zinc-300 dark:border-zinc-700 hover:bg-zinc-100 dark:hover:bg-zinc-800"
                                                    )}
                                                >
                                                    {info.emoji} {info.name}
                                                </button>
                                            );
                                        })}
                                    </div>
                                    <p className="text-[10px] text-zinc-500 mt-2">Ââ©‰Ωô‰ΩçÁΩÆÂ∞ÜËá™Âä®Â°´ÂÖÖÊùëÊ∞ë</p>
                                </div>

                                <div>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={config.witchSelfSave || false}
                                            onChange={e => setConfig({...config, witchSelfSave: e.target.checked})}
                                            className="w-4 h-4"
                                        />
                                        <span className="text-sm">ÂÖÅËÆ∏Â•≥Â∑´Ëá™Êïë</span>
                                    </label>
                                    <p className="text-[10px] text-zinc-500 mt-1">ÈªòËÆ§Á¶ÅÊ≠¢Â•≥Â∑´‰ΩøÁî®Ëß£ËçØÊïëËá™Â∑±</p>
                                </div>

                                <div className="p-3 rounded-lg bg-amber-50 dark:bg-amber-900/20 text-xs text-amber-700 dark:text-amber-400">
                                    <p className="font-bold mb-1">‚ö†Ô∏è ÊèêÁ§∫</p>
                                    <p>ÂºÄÂßãÊ∏∏ÊàèÂêéÔºåÁãº‰∫∫Â∞ÜËá™Âä®Ë¢´ÊãâÂÖ•Â∞èÁæ§‰Ωú‰∏∫ÁßÅËÅäÈ¢ëÈÅì„ÄÇ</p>
                                </div>
                            </div>

                            <div className="mt-6 flex justify-end gap-2">
                                <button onClick={onClose} className="px-4 py-2 text-sm text-zinc-500">ÂèñÊ∂à</button>
                                <button
                                    onClick={onStart}
                                    disabled={totalPlayers < 4}
                                    className="px-4 py-2 text-sm bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50 flex items-center gap-2"
                                >
                                    <Icons.Wolf className="w-4 h-4"/> ÂºÄÂßãÊ∏∏Êàè
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className={cn("flex h-screen w-full overflow-hidden transition-colors duration-300", darkMode ? "bg-zinc-950 text-zinc-100" : "bg-zinc-50 text-zinc-900")}>
                    <Toast toasts={toasts} removeToast={(id) => setToasts(p => p.filter(t => t.id !== id))} />

                    <GlobalConfigModal
                        open={showConfig}
                        onClose={() => setShowConfig(false)}
                        configs={configs} setConfigs={setConfigs}
                        prompts={prompts} setPrompts={setPrompts}
                        directorConfigId={directorConfigId} setDirectorConfigId={setDirectorConfigId}
                        directorRule={directorRule} setDirectorRule={setDirectorRule}
                        directorMode={directorMode} setDirectorMode={setDirectorMode}
                        contextWindowSize={contextWindowSize} setContextWindowSize={setContextWindowSize}
                        werewolfRolePrompts={werewolfRolePrompts} setWerewolfRolePrompts={setWerewolfRolePrompts}
                        darkMode={darkMode} addToast={addToast}
                    />

                    <AgentModal
                        open={showAgentModal}
                        onClose={() => setShowAgentModal(false)}
                        agent={editingAgentId ? agents.find(a => a.id === editingAgentId) : null}
                        isNew={!editingAgentId}
                        configs={configs} prompts={prompts}
                        onSave={handleSaveAgent} onDelete={handleDeleteAgent}
                        darkMode={darkMode}
                    />

                    <WerewolfSetupModal
                        open={showWerewolfSetup}
                        onClose={() => setShowWerewolfSetup(false)}
                        config={werewolfConfig}
                        setConfig={setWerewolfConfig}
                        onStart={startWerewolfGame}
                        agents={agents}
                        darkMode={darkMode}
                    />

                    {/* Sidebar */}
                    <div className="w-64 border-r border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 flex flex-col shrink-0">
                        <div className="p-4 border-b border-zinc-200 dark:border-zinc-800 flex justify-between items-center">
                            <h1 className="font-bold flex items-center gap-2"><Icons.Users className="w-5 h-5 text-purple-600"/> ÊºîÂëòÂêçÂçï</h1>
                            <button onClick={() => setDarkMode(!darkMode)} className="text-zinc-500 hover:text-zinc-300">
                                {darkMode ? <Icons.Sun className="w-5 h-5"/> : <Icons.Moon className="w-5 h-5"/>}
                            </button>
                        </div>
                        <div className="p-2 overflow-y-auto flex-1 space-y-2">
                            {agents.map(agent => {
                                const cfg = configs.find(c => c.id === agent.configId);
                                const pmt = prompts.find(p => p.id === agent.promptId);
                                const inSmallGroup = smallGroupMembers.includes(agent.id);
                                const wwPlayersSource = werewolfGame?.players?.length ? werewolfGame.players : werewolfLastPlayers;
                                const wwPlayer = wwPlayersSource?.find(p => p.id === agent.id);
                                const wwRoleInfo = wwPlayer ? WEREWOLF_ROLES[wwPlayer.role] : null;
                                return (
                                    <div key={agent.id} className={cn("group p-3 rounded-lg flex items-center gap-3 border transition-all relative", agent.enabled ? (darkMode ? "bg-zinc-800 border-zinc-700" : "bg-white border-purple-200 shadow-sm") : "opacity-50 border-transparent")}>
                                        <div onClick={() => setAgents(prev => prev.map(a => a.id === agent.id ? {...a, enabled: !a.enabled} : a))} className="cursor-pointer flex items-center gap-3 flex-1">
                                            <div className={cn("w-10 h-10 rounded-full flex items-center justify-center text-white font-bold shrink-0", agent.avatarColor)}>{agent.name[0]}</div>
                                            <div className="min-w-0">
                                                <div className="font-medium text-sm truncate flex items-center gap-2">
                                                    <span>{agent.name}</span>
                                                    {directorMode === 'werewolf' && werewolfGame && werewolfRevealAll && wwRoleInfo && (
                                                        <span className={cn("text-[10px] px-2 py-0.5 rounded-full border", wwPlayer?.alive ? "border-purple-500/40 text-purple-400" : "border-zinc-500/40 text-zinc-400 line-through")}>
                                                            {wwRoleInfo.emoji} {wwRoleInfo.name}
                                                        </span>
                                                    )}
                                                </div>
                                                <div className="text-xs text-zinc-500 truncate flex items-center gap-1">
                                                    <span className="max-w-[60px] truncate">{cfg?.name}</span> ‚Ä¢ <span className="max-w-[60px] truncate">{pmt?.name}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div className="absolute right-2 flex items-center gap-1 opacity-0 group-hover:opacity-100">
                                            <button onClick={() => toggleSmallGroupMember(agent.id)} className={cn("p-1.5 rounded", inSmallGroup ? "text-green-500" : "text-zinc-400 hover:text-zinc-500")} title={inSmallGroup ? "ÁßªÂá∫Â∞èÁæ§" : "ÊãâÂÖ•Â∞èÁæ§"}><Icons.Users className="w-4 h-4"/></button>
                                            <button onClick={() => { setEditingAgentId(agent.id); setShowAgentModal(true); }} className="p-1.5 hover:bg-black/10 rounded"><Icons.Edit className="w-4 h-4 text-zinc-400"/></button>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                        <div className="p-4 border-t border-zinc-200 dark:border-zinc-800">
                            <button onClick={() => { setEditingAgentId(null); setShowAgentModal(true); }} className="w-full py-2 bg-zinc-100 dark:bg-zinc-800 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-lg text-sm font-medium transition-colors flex items-center justify-center gap-2 text-zinc-600 dark:text-zinc-300"><Icons.Plus className="w-4 h-4"/> Ê∑ªÂä†ÊºîÂëò</button>
                        </div>
                    </div>

                    {/* Chat Area */}
                    <div className="flex-1 flex flex-col relative">
                        <div className="h-14 border-b border-zinc-200 dark:border-zinc-800 bg-white/80 dark:bg-zinc-950/80 backdrop-blur flex items-center justify-between px-6 z-10">
                            <div className="flex items-center gap-4">
                                <div className="font-bold">Áæ§ËÅäÂâßÂú∫ <span className="text-xs font-normal text-zinc-500 ml-2">Director Mode</span></div>
                                {directorStatus === 'thinking' && <div className="flex items-center gap-2 text-xs text-purple-500 animate-pulse"><Icons.Brain className="w-4 h-4"/> ÂØºÊºîË∞ÉÂ∫¶‰∏≠...</div>}
                            </div>
                            <div className="flex items-center gap-2">
                                <button onClick={() => exportChat('md', 'all')} className="px-3 py-1.5 rounded-full text-xs font-bold border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200 flex items-center gap-1" title="ÂØºÂá∫‰∏∫ Markdown">
                                    <Icons.Download className="w-3.5 h-3.5"/> ÂØºÂá∫
                                </button>
                                <button type="button" onClick={(e) => { e.preventDefault(); e.stopPropagation(); clearChat('all', { confirm: false }); }} className="px-3 py-1.5 rounded-full text-xs font-bold border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200" title="Ê∏ÖÁ©∫Â§ßÁæ§‰∏éÂ∞èÁæ§">
                                    Ê∏ÖÁ©∫
                                </button>
                                {directorMode === 'werewolf' && (
                                    <>
                                        <button 
                                            onClick={() => setWerewolfRevealAll(prev => !prev)}
                                            className={cn("flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-bold transition-all border", werewolfRevealAll ? "bg-purple-500/10 text-purple-600 border-purple-500/20" : "bg-zinc-100 text-zinc-500 border-transparent dark:bg-zinc-800 dark:text-zinc-400")}
                                        >
                                            <Icons.Eye className="w-3.5 h-3.5"/> {werewolfRevealAll ? 'ÈöêËóèËßÜÈáé' : 'ÂÖ®Â±ÄËßÜÈáé'}
                                        </button>
                                        <button 
                                            onClick={() => werewolfGame ? toggleWerewolfPause() : setShowWerewolfSetup(true)} 
                                            className={cn("flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-bold transition-all border", werewolfGame ? "bg-amber-500/10 text-amber-600 border-amber-500/20" : "bg-red-600 text-white border-red-600")}
                                        >
                                            <Icons.Wolf className="w-3.5 h-3.5"/> {werewolfGame ? (werewolfGame.paused ? 'ÁªßÁª≠Ê∏∏Êàè' : 'ÊöÇÂÅúÊ∏∏Êàè') : 'ÂºÄÂßãÁãº‰∫∫ÊùÄ'}
                                        </button>
                                    </>
                                )}
                                {directorMode !== 'werewolf' && (
                                    <button onClick={() => setIsAutoPlay(prev => !prev)} className={cn("flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-bold transition-all border", isAutoPlay ? "bg-green-500/10 text-green-600 border-green-500/20" : "bg-zinc-100 text-zinc-500 border-transparent dark:bg-zinc-800 dark:text-zinc-400")}> 
                                        {isAutoPlay ? <><Icons.Pause className="w-3 h-3"/> Ëá™Âä®‰∫íÊÄº‰∏≠</> : <><Icons.Play className="w-3 h-3"/> ÂºÄÂêØËá™Âä®‰∫íÊÄº</>}
                                    </button>
                                )}
                                <button onClick={() => setSmallGroupVisible(prev => !prev)} className="px-3 py-1.5 rounded-full text-xs font-bold border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200">
                                    {smallGroupVisible ? 'Êî∂Ëµ∑Â∞èÁæ§' : 'Â±ïÂºÄÂ∞èÁæ§'}
                                </button>
                                <button onClick={() => setShowConfig(true)} className="p-2 text-zinc-400 hover:text-zinc-600 dark:hover:text-zinc-200" title="ÂÖ®Â±ÄËµÑÊ∫êÈÖçÁΩÆ"><Icons.Settings className="w-5 h-5"/></button>
                            </div>
                        </div>

                        <div className="flex-1 flex gap-4 p-4 bg-zinc-50 dark:bg-zinc-950/50 min-h-0">
                            <div className="flex flex-1 flex-col min-h-0">
                                <div className="flex-1 overflow-y-auto space-y-6 pr-1 min-h-0">
                                    {directorMode === 'werewolf' && (werewolfGame || werewolfLastPlayers.length > 0) && werewolfRevealAll && (
                                        <div className="p-4 rounded-xl border border-purple-300/30 bg-purple-50/50 dark:bg-purple-900/10 dark:border-purple-700/40">
                                            <div className="text-xs font-bold text-purple-600 mb-2 flex items-center gap-2">
                                                <Icons.Eye className="w-4 h-4"/> ÂÖ®Â±ÄËßÜÈáéÔºàË∫´‰ªΩÂÖ¨ÂºÄÔºâ
                                            </div>
                                            <div className="grid grid-cols-2 gap-2 text-xs">
                                                {(werewolfGame?.players?.length ? werewolfGame.players : werewolfLastPlayers).map(p => {
                                                    const roleInfo = WEREWOLF_ROLES[p.role];
                                                    return (
                                                        <div key={p.id} className="flex items-center justify-between px-3 py-2 rounded-lg bg-white/70 dark:bg-zinc-900/70 border border-zinc-200/50 dark:border-zinc-800/50">
                                                            <span className={cn(p.alive ? "text-zinc-700 dark:text-zinc-200" : "text-zinc-400 line-through")}>{p.name}</span>
                                                            <span className="text-purple-600">{roleInfo?.emoji} {roleInfo?.name}</span>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}
                                    {messages.length === 0 && (
                                        <div className="h-full flex flex-col items-center justify-center opacity-30 select-none">
                                            <Icons.Users className="w-20 h-20 mb-4 text-zinc-400"/>
                                            <p>ËØ∑ÂÖàÂú®Âè≥‰∏äËßíÈÖçÁΩÆËµÑÊ∫ê</p>
                                        </div>
                                    )}
                                    {messages.map((msg) => {
                                        const isUser = msg.role === 'user';
                                        const isSystem = msg.isSystem;
                                        const isAction = msg.isAction && isUser;
                                        const userBubbleClass = isAction
                                            ? (msg.actionType === 'vote' ? "bg-emerald-600 text-white rounded-tr-none ring-1 ring-emerald-300/40" : "bg-amber-600 text-white rounded-tr-none ring-1 ring-amber-300/40")
                                            : "bg-zinc-800 text-white rounded-tr-none";
                                        if (isSystem) {
                                            return (
                                                <div key={msg.id} className="flex justify-center">
                                                    <div className="max-w-3xl w-full">
                                                        <div className="mx-auto px-4 py-2 rounded-xl border text-xs text-center bg-indigo-50 text-indigo-700 border-indigo-200 dark:bg-indigo-900/30 dark:text-indigo-200 dark:border-indigo-700/50">
                                                            <Markdown content={msg.content} />
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        }
                                        return (
                                            <div key={msg.id} className={cn("flex gap-4 max-w-3xl group", isUser ? "ml-auto flex-row-reverse" : "")}> 
                                                <div className={cn("w-10 h-10 rounded-full flex items-center justify-center text-white shrink-0 shadow-lg mt-1", isUser ? "bg-zinc-800 dark:bg-zinc-700" : (msg.avatarColor || "bg-gray-500"))}>
                                                    {isUser ? <Icons.User className="w-5 h-5"/> : msg.senderName?.[0]}
                                                </div>
                                                <div className={cn("flex flex-col max-w-[80%]", isUser ? "items-end" : "items-start")}> 
                                                    <div className="flex items-center gap-2 mb-1 px-1">
                                                        <span className="text-xs font-bold text-zinc-500">{isUser ? "‰Ω†" : msg.senderName}</span>
                                                        {msg.time && <span className="text-[10px] text-zinc-400">{msg.time}</span>}
                                                        <button onClick={() => copyToClipboard(msg.content)} className="ml-1 p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity text-zinc-400 hover:text-zinc-600" title="Â§çÂà∂Ê∂àÊÅØ">
                                                            <Icons.Copy className="w-3.5 h-3.5"/>
                                                        </button>
                                                    </div>
                                                    <div className={cn("rounded-2xl px-5 py-3 shadow-sm text-sm leading-relaxed", isUser ? userBubbleClass : "bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 rounded-tl-none dark:text-zinc-200")}> 
                                                        {msg.isThinking ? <div className="flex gap-1 py-1 h-5 items-center"><div className="w-1.5 h-1.5 bg-current rounded-full typing-dot"></div><div className="w-1.5 h-1.5 bg-current rounded-full typing-dot"></div><div className="w-1.5 h-1.5 bg-current rounded-full typing-dot"></div></div> : <Markdown content={msg.content} />}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                    <div ref={messagesEndRef} />
                                </div>
                                <div className="mt-4 bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 rounded-xl p-3">
                                    <div className="flex flex-wrap gap-2 mb-2">
                                        <button onClick={() => quickAt('ÊâÄÊúâ‰∫∫', 'main')} className="px-2 py-1 text-xs rounded-full border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200 flex items-center gap-1">
                                            <Icons.AtSign className="w-3 h-3"/> @ÊâÄÊúâ‰∫∫
                                        </button>
                                        {getEnabledAgents().map(a => (
                                            <button key={a.id} onClick={() => quickAt(a.name, 'main')} className="px-2 py-1 text-xs rounded-full border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200">
                                                @{a.name}
                                            </button>
                                        ))}
                                    </div>
                                    <div className="flex gap-3">
                                        <input value={input} onChange={e => setInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && handleUserSend()} placeholder={isAutoPlay ? "ÊèíÂò¥..." : "ËØ¥ÁÇπ‰ªÄ‰πà..."} className="flex-1 bg-zinc-100 dark:bg-zinc-900 border-none rounded-xl px-4 py-3 outline-none focus:ring-2 focus:ring-purple-500/50 dark:text-white transition-all" disabled={activeSpeakerId !== null && !isAutoPlay} />
                                        <button onClick={handleUserSend} disabled={!input.trim() || (activeSpeakerId !== null && !isAutoPlay)} className="bg-purple-600 hover:bg-purple-700 text-white p-3 rounded-xl disabled:opacity-50 disabled:cursor-not-allowed transition-colors shadow-lg shadow-purple-500/20"><Icons.Send className="w-5 h-5"/></button>
                                    </div>
                                </div>
                            </div>

                            {smallGroupVisible && (
                                <>
                                    <div onMouseDown={() => setIsDragging(true)} className="hidden xl:block w-1.5 cursor-col-resize rounded-full bg-zinc-200/80 dark:bg-zinc-800/80" />
                                    <div className="flex flex-col min-h-0 border border-zinc-200 dark:border-zinc-800 rounded-2xl bg-white/70 dark:bg-zinc-900/70" style={{ width: smallGroupWidth }}>
                                        <div className="px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 flex items-center justify-between">
                                            <div className="font-bold text-sm">{werewolfGame ? 'üê∫ Áãº‰∫∫ÂØÜËÅä' : 'ÁßÅÂØÜÂ∞èÁæ§'}</div>
                                            <div className="text-xs text-zinc-500">ÊàêÂëò {getSmallGroupAgents().length}</div>
                                        </div>
                                        {(() => {
                                            const humanPlayer = werewolfGame?.players?.find(p => p.isHuman);
                                            const canSeeWolfChat = !werewolfGame || werewolfRevealAll || humanPlayer?.role === 'wolf';
                                            if (!canSeeWolfChat) {
                                                return (
                                                    <div className="flex-1 flex items-center justify-center text-xs text-zinc-500 p-4">
                                                        Áãº‰∫∫ÂØÜËÅä‰ªÖÁãº‰∫∫ÂèØËßÅ
                                                    </div>
                                                );
                                            }
                                            return (
                                                <>
                                                    <div className="flex-1 overflow-y-auto p-3 space-y-4 min-h-0">
                                                        {smallGroupMessages.length === 0 && (
                                                            <div className="h-full flex flex-col items-center justify-center opacity-40 select-none text-xs text-zinc-500">
                                                                <p>ËøôÈáåÊòØÂ∞èÁæ§ËÅäÂ§©</p>
                                                                <p>@Êüê‰ΩçÊºîÂëò Êàñ @ÊâÄÊúâ‰∫∫</p>
                                                            </div>
                                                        )}
                                                        {smallGroupMessages.map((msg) => {
                                                            const isUser = msg.role === 'user';
                                                            const isSystem = msg.isSystem;
                                                            const isAction = msg.isAction && isUser;
                                                            const userBubbleClass = isAction
                                                                ? (msg.actionType === 'vote' ? "bg-emerald-600 text-white rounded-tr-none ring-1 ring-emerald-300/40" : "bg-amber-600 text-white rounded-tr-none ring-1 ring-amber-300/40")
                                                                : "bg-zinc-800 text-white rounded-tr-none";
                                                            if (isSystem) {
                                                                return (
                                                                    <div key={msg.id} className="flex justify-center">
                                                                        <div className="mx-auto px-3 py-2 rounded-xl border text-[11px] text-center bg-rose-50 text-rose-700 border-rose-200 dark:bg-rose-900/30 dark:text-rose-200 dark:border-rose-700/50">
                                                                            <Markdown content={msg.content} />
                                                                        </div>
                                                                    </div>
                                                                );
                                                            }
                                                            return (
                                                                <div key={msg.id} className={cn("flex gap-3 group", isUser ? "ml-auto flex-row-reverse" : "")}> 
                                                                    <div className={cn("w-8 h-8 rounded-full flex items-center justify-center text-white shrink-0 shadow", isUser ? "bg-zinc-800 dark:bg-zinc-700" : (msg.avatarColor || "bg-gray-500"))}>
                                                                        {isUser ? <Icons.User className="w-4 h-4"/> : msg.senderName?.[0]}
                                                                    </div>
                                                                    <div className={cn("flex flex-col max-w-[75%]", isUser ? "items-end" : "items-start")}> 
                                                                        <div className="flex items-center gap-2 mb-1 px-1">
                                                                            <span className="text-[10px] font-bold text-zinc-500">{isUser ? "‰Ω†" : msg.senderName}</span>
                                                                            <button onClick={() => copyToClipboard(msg.content)} className="ml-1 p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity text-zinc-400 hover:text-zinc-600" title="Â§çÂà∂Ê∂àÊÅØ">
                                                                                <Icons.Copy className="w-3 h-3"/>
                                                                            </button>
                                                                        </div>
                                                                        <div className={cn("rounded-2xl px-4 py-2 shadow-sm text-xs leading-relaxed", isUser ? userBubbleClass : "bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-tl-none dark:text-zinc-200")}> 
                                                                            {msg.isThinking ? <div className="flex gap-1 py-1 h-4 items-center"><div className="w-1 h-1 bg-current rounded-full typing-dot"></div><div className="w-1 h-1 bg-current rounded-full typing-dot"></div><div className="w-1 h-1 bg-current rounded-full typing-dot"></div></div> : <Markdown content={msg.content} />}
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                        <div ref={smallGroupEndRef} />
                                                    </div>
                                                    <div className="p-3 border-t border-zinc-200 dark:border-zinc-800">
                                                        <div className="flex flex-wrap gap-2 mb-2">
                                                            <button onClick={() => quickAt('ÊâÄÊúâ‰∫∫', 'small')} className="px-2 py-1 text-[10px] rounded-full border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200 flex items-center gap-1">
                                                                <Icons.AtSign className="w-3 h-3"/> @ÊâÄÊúâ‰∫∫
                                                            </button>
                                                            {getSmallGroupAgents().map(a => (
                                                                <button key={a.id} onClick={() => quickAt(a.name, 'small')} className="px-2 py-1 text-[10px] rounded-full border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200">
                                                                    @{a.name}
                                                                </button>
                                                            ))}
                                                            <button onClick={() => exportChat('md', 'small')} className="ml-auto px-2 py-1 text-[10px] rounded-full border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200 flex items-center gap-1" title="ÂØºÂá∫Â∞èÁæ§">
                                                                <Icons.Download className="w-3 h-3"/> ÂØºÂá∫
                                                            </button>
                                                            <button type="button" onClick={(e) => { e.preventDefault(); e.stopPropagation(); clearChat('small', { confirm: false }); }} className="px-2 py-1 text-[10px] rounded-full border border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200" title="Ê∏ÖÁ©∫Â∞èÁæ§">
                                                                Ê∏ÖÁ©∫
                                                            </button>
                                                        </div>
                                                        <div className="flex gap-2">
                                                            <input value={smallGroupInput} onChange={e => setSmallGroupInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && handleSmallGroupSend()} placeholder="Â∞èÁæ§ÂèëË®Ä..." className="flex-1 bg-zinc-100 dark:bg-zinc-900 border-none rounded-xl px-3 py-2 text-xs outline-none focus:ring-2 focus:ring-purple-500/50 dark:text-white transition-all" disabled={activeSpeakerId !== null && !isAutoPlay} />
                                                            <button onClick={handleSmallGroupSend} disabled={!smallGroupInput.trim() || (activeSpeakerId !== null && !isAutoPlay)} className="bg-purple-600 hover:bg-purple-700 text-white p-2 rounded-xl disabled:opacity-50 disabled:cursor-not-allowed transition-colors"><Icons.Send className="w-4 h-4"/></button>
                                                        </div>
                                                    </div>
                                                </>
                                            );
                                        })()}
                                    </div>
                                </>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
